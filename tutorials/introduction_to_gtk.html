<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: Introduction to Gtk</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contributors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="Introduction to Gtk" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
    <li><a href="../papers.html">Papers</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../releases/">Releases</a></li>
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development Tools</a></li>
    <li><a href="../books.html#manual">User Manual</a></li>
    <li><a href="../cheat_sheets.html">Cheat Sheets</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">GitHub</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../planet/">Blogs</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span><a href="./">Tutorials</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>Introduction to Gtk
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

<h1>Introduction to Gtk</h1>

<h2><a name="Lablgtk_and_writing_Gtk_applications"></a>
  Lablgtk and writing Gtk applications</h2>

<p><a title="http://www.gtk.org/" class="external" href="http://www.gtk.org/">Gtk+</a> is a toolkit for writing graphical applications, and <a title="http://wwwfun.kurims.kyoto-u.ac.jp/soft/olabl/lablgtk.html" class="external" href="http://wwwfun.kurims.kyoto-u.ac.jp/soft/olabl/lablgtk.html">lablgtk</a> is the OCaml interface for Gtk. Gtk and lablgtk are available for Unix and Windows platforms. In this tutorial I'm going to concentrate on the older but more stable Gtk version 1.2.  Gtk 2.x has some incompatibilities with Gtk 1.2, although mostly you won't notice the difference. On Windows, Gtk 1.2 has a non-native look and feel, but this is corrected in Gtk 2.x by the use of <a title="http://gtk-wimp.sourceforge.net/" class="external" href="http://gtk-wimp.sourceforge.net/">Gtk-Wimp</a> (a Windows native theme for Gtk).</p>
<p>Lablgtk makes ambitious use of advanced features of the OCaml type system. Make sure you're familiar with labelled and optional arguments and polymorphic variants (<a title="labels" class="internal" href="labels.html">labels</a>) or you won't have any idea what's going on in this chapter.  As it is, even the author of this tutorial finds ploughing through the lablgtk source code pretty hard work!</p>

<h3>Simple lablgtk program</h3>
<p>Actually, not so simple. This program has a menu with a &quot;quit&quot; option, and a button in the main area which you can press:</p>
<pre><span class="listing"><span class="kwa">open</span> <span class="ocaml-mod">GMain</span>
<span class="kwa">open</span> <span class="ocaml-mod">GdkKeysyms</span>

<span class="kwa">let</span> <span class="ocaml-function">main</span> <span class="ocaml-variable">() </span>=
  <span class="kwa">let </span><span class="ocaml-variable">window</span> = <span class="ocaml-mod">GWindow</span>.window ~width:320 ~height:240
                 ~title:&quot;Simple lablgtk program&quot; () <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">vbox</span> = <span class="ocaml-mod">GPack</span>.vbox ~packing:window#add () <span class="kwa">in</span>
  window#connect#destroy ~callback:<span class="ocaml-mod">Main</span>.quit;

  <span class="ocaml-comment">(* Menu bar *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">menubar</span> = <span class="ocaml-mod">GMenu</span>.menu_bar ~packing:vbox#pack () <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">factory</span> = <span class="kwb">new</span> <span class="ocaml-mod">GMenu</span>.factory menubar <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">accel_group</span> = factory#accel_group <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">file_menu</span> = factory#add_submenu &quot;File&quot; <span class="kwa">in</span>

  <span class="ocaml-comment">(* File menu *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">factory</span> = <span class="kwb">new</span> <span class="ocaml-mod">GMenu</span>.factory file_menu ~accel_group <span class="kwa">in</span>
  factory#add_item &quot;Quit&quot; ~key:_Q ~callback: <span class="ocaml-mod">Main</span>.quit;

  <span class="ocaml-comment">(* Button *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">button</span> = <span class="ocaml-mod">GButton</span>.button ~label:&quot;Push me!&quot;
                 ~packing:vbox#add () <span class="kwa">in</span>
  button#connect#clicked ~callback: (<span class="kwb">fun</span> () -&gt; prerr_endline &quot;Ouch!&quot;);

  <span class="ocaml-comment">(* Display the windows and enter Gtk+ main loop *)</span>
  window#add_accel_group accel_group;
  window#show ();
  <span class="ocaml-mod">Main</span>.main ()

<span class="kwa">let</span> () = main ()</span></pre>

<p>Save this to a file <code>simple.ml</code> and compile it like this:</p>
<pre>
ocamlc -g -w s -I +lablgtk lablgtk.cma gtkInit.cmo simple.ml -o simple
</pre>

<p>This is what you should see when you run it:</p>
<center>
  <img src=".././img/simplee29b.gif" alt="Simple lablgtk program" height="277" width="327"/></center>
<p>Let's analyse the program line by line to see what's going on.</p>
<pre><span class="listing"><span class="kwa">open</span> <span class="ocaml-mod">GMain</span>
<span class="kwa">open</span> <span class="ocaml-mod">GdkKeysyms</span></span></pre>

<p><code>GMain</code> provides useful functions like the Gtk main loop, so I find it a good idea to always open this module. <code>GdkKeysyms</code> provides some key definitions, in this case <code>_Q</code> for the Ctrl + Q key combination.</p>
<pre><span class="listing"><span class="kwa">let </span><span class="ocaml-variable">window</span> = <span class="ocaml-mod">GWindow</span>.window ~width:320 ~height:240
                 ~title:&quot;Simple lablgtk program&quot; () <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">vbox</span> = <span class="ocaml-mod">GPack</span>.vbox ~packing:window#add () <span class="kwa">in</span>
  window#connect#destroy ~callback:<span class="ocaml-mod">Main</span>.quit;</span></pre>

<p>Firstly we create the toplevel window. Every Gtk program needs at least one. Notice three things: firstly <code>GWindow.window</code> is actually a helper function which creates a <code>window</code> object for you. For various reasons which we'll discuss in the intensive section at the end of this chapter, you shouldn't create lablgtk objects using <code>new <em>classname arguments...</em></code>, but instead use one of these helper functions. The helper functions are often named the same as the class which they create. Secondly lablgtk makes extensive use of the <code>~label</code> (labelled and optional arguments).  You'll get used to this quickly. Thirdly see the apparently useless <code>()</code> (unit) argument to <code>GWindow.window</code>. It's actually not useless, but the only way for OCaml to tell the difference between a partial and full function application in the presence of optional arguments.</p>
<p>A <code>vbox</code> is a vertical layout widget. It's a container which contains other widgets but isn't normally visible by itself. The <code>~packing</code> argument looks odd (indeed it is). It's just a shorthand way of writing:</p>
<pre><span class="listing"><span class="kwa">let </span><span class="ocaml-variable">vbox</span> = <span class="ocaml-mod">GPack</span>.vbox () <span class="kwa">in</span>
  window#add vbox;</span></pre>

<p>The two forms are, as far as I can tell, identical. The first way is a bit shorter.</p>
<p><code>window#connect#destroy ~callback:Main.quit;</code> is an example of connecting a <em>signal</em> to a function. In this case the <code>destroy</code> signal, received by the window when someone presses the &quot;X&quot; in the corner, will cause a call to <code>Main.quit ()</code> (note extra unit arg).</p>
<p>Creating the menubar and File -&gt; Quit button is straightforward enough. Notice the <code>accel_group</code> object which is used to keep track of accelerator buttons.  The <code>menubar</code> is packed first into the <code>vbox</code>:</p>
<pre><span class="listing"><span class="ocaml-comment">(* Menu bar *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">menubar</span> = <span class="ocaml-mod">GMenu</span>.menu_bar ~packing:vbox#pack () <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">factory</span> = <span class="kwb">new</span> <span class="ocaml-mod">GMenu</span>.factory menubar <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">accel_group</span> = factory#accel_group <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">file_menu</span> = factory#add_submenu &quot;File&quot; <span class="kwa">in</span>

  <span class="ocaml-comment">(* File menu *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">factory</span> = <span class="kwb">new</span> <span class="ocaml-mod">GMenu</span>.factory file_menu ~accel_group <span class="kwa">in</span>
  factory#add_item &quot;Quit&quot; ~key:_Q ~callback: <span class="ocaml-mod">Main</span>.quit;</span></pre>

<p>Next up we create the button and pack it in the <code>vbox</code>. Notice the <code>clicked</code> signal which is connected to an anonymous function:</p>
<pre><span class="listing">&nbsp; <span class="ocaml-comment">(* Button *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">button</span> = <span class="ocaml-mod">GButton</span>.button ~label:&quot;Push me!&quot;
                 ~packing:vbox#add () <span class="kwa">in</span>
  button#connect#clicked ~callback: (<span class="kwb">fun</span> () -&gt; prerr_endline &quot;Ouch!&quot;);</span></pre>

<p>This line just causes the accelerator keys (eg. Ctrl Q) to work:</p>
<pre><span class="listing">window#add_accel_group accel_group;</span></pre>

<p>Finally two lines which are essential. All Gtk widgets must be &quot;shown&quot; before they will appear, by calling the <code>#show</code> method. However lablgtk, by default, automatically shows all widgets <em>except</em> toplevel windows. Thus we need to call <code>window#show ()</code> explicitly. <code>Main.main ()</code> is the Gtk main loop - the bit which runs and handles events. Gtk is event driven so everything else happens in a callback as a result of some signal received.</p>
<pre><span class="listing">&nbsp; window#show ();
  <span class="ocaml-mod">Main</span>.main ()</span></pre>

<h3>Gtk tutorial</h3>
<p>Read <a title="http://www.gtk.org/tutorial1.2/" class="external" href="http://www.gtk.org/tutorial1.2/">this Gtk tutorial</a>  to find out more about Gtk. Lablgtk contains a pretty complete mapping of the Gtk+ API.</p>

<h3>Graph widget</h3>
<p>Now we're going to get a little bit more adventurous and write our own widget. This is going to be a simple graph, with a scrollbar at the bottom allowing you to scroll left and right through the data. The graph itself is going to be drawn on a Gtk drawing area widget. The Gtk drawing area is very simple, just an empty space in which you can execute your own drawing commands to draw lines, rectangles, text and so on.</p>
<p>Before starting we need to think about the overall structure of our graph widget. I'm going to have it be a vbox, with the drawing area in the top part, and the scrollbar in the bottom part. This is the overall structure of our class:</p>
<pre><span class="listing"><span class="kwa">class</span> <span class="ocaml-function">graph</span> <span class="ocaml-variable">?width ?height ?packing ?show array </span>=
  <span class="ocaml-comment">(* The initialization code will go here. *)</span>

  <span class="kwa">object</span> (self)
    <span class="kwa">inherit</span> widget vbox#as_widget

    <span class="ocaml-comment">(* Methods will go here. *)</span>

    <span class="kwa">method</span> <span class="ocaml-function">init</span><span class="ocaml-ty"></span> =
      <span class="ocaml-comment">(* Further initialization will go here. *)</span>
  <span class="kwa">end</span></span></pre>

<p>To create a widget you will do:</p>
<pre><span class="listing"><span class="kwa">let </span><span class="ocaml-variable">graph</span> = <span class="kwb">new</span> graph <span class="kwa">in</span>
graph#init;</span></pre>

<p>Note the two-stage initialization process. This is actually an unfortunate hack. You'll see why it's necessary once we start to fill in the code. Perhaps a reader can suggest a way around this?</p>
<p>The <code>inherit widget vbox#as_widget</code> is interesting. You'll have to read the section below entited <em>Structure of lablgtk</em> to understand it fully, but basically it causes a graph to be a subclass of widget.</p>
<p>Let's have a look at the initialization code in more detail. </p>
<pre><span class="listing"><span class="kwa">class</span> <span class="ocaml-function">graph</span> <span class="ocaml-variable">?width ?height ?packing ?show array </span>=
  <span class="ocaml-comment">(* <span class="ocaml-mod">Constants</span>. *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">page_size</span> = 10 <span class="kwa">in</span>            <span class="ocaml-comment">(* Number <span class="kwb">of</span> bars on &quot;page&quot;. *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">max_y</span> = 10 <span class="kwa">in</span>                <span class="ocaml-comment">(* Maximum on Y scale. *)</span>

  <span class="ocaml-comment">(* Number <span class="kwb">of</span> data points. *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">array_size</span> = <span class="ocaml-mod">Array</span>.length array <span class="kwa">in</span>

  <span class="ocaml-comment">(* Create the containing vbox. *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">vbox</span> = <span class="ocaml-mod">GPack</span>.vbox ?width ?height ?packing ?show () <span class="kwa">in</span>

  <span class="ocaml-comment">(* Create the drawing area. *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">da</span> = <span class="ocaml-mod">GMisc</span>.drawing_area ~packing:vbox#add () <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">drawable</span> = lazy (<span class="kwb">new</span> <span class="ocaml-mod">GDraw</span>.drawable da#misc#window) <span class="kwa">in</span>

  <span class="ocaml-comment">(* Create the scrollbar. *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">adjustment</span> = <span class="ocaml-mod">GData</span>.adjustment
                     ~lower:0. ~upper:(float_of_int (array_size-1))
                     ~step_incr:1. ~page_incr:(float_of_int page_size) () <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">scrollbar</span> =
    <span class="ocaml-mod">GRange</span>.scrollbar `HORIZONTAL ~adjustment ~packing:vbox#pack () <span class="kwa">in</span>

  <span class="kwa">object</span> (self)
    <span class="kwa">inherit</span> widget vbox#as_widget

    <span class="ocaml-comment">(* Methods will go here. *)</span>

    <span class="kwa">method</span> <span class="ocaml-function">private</span> <span class="ocaml-variable">repaint () </span>=
      <span class="ocaml-comment">(* Repaint the widget. See below. *)</span>

    <span class="kwa">method</span> <span class="ocaml-function">init</span><span class="ocaml-ty"></span> =
      da#event#connect#expose
        ~callback:(<span class="kwb">fun</span> _ -&gt; self#repaint (); false);
      adjustment#connect#value_changed
        ~callback:(<span class="kwb">fun</span> _ -&gt; self#repaint ())

  <span class="kwa">end</span></span></pre>

<p>The let-bindings before the start of <code>object</code> define constants such as <code>page_size</code>, but also create the Gtk objects like vbox, drawing area, scrollbar and adjustment. (An adjustment is an abstract object which records the position of a scrollbar. Notice how in the <code>init</code> method we attach a signal to the adjustment so that when the scrollbar moves (ie. adjustment changes) we repaint the whole widget.) The private <code>repaint</code> method is where the action is, as it were. That method will actually be responsible for drawing the graph, axes, title and so on.</p>
<p>We'll see that in just a moment, but let's concentrate on the simpler methods of the object first:</p>
<pre><span class="listing"><span class="kwa">object</span> (self)
    <span class="kwa">inherit</span> widget vbox#as_widget

    <span class="ocaml-comment">(* The title <span class="kwb">of</span> the graph. *)</span>
    <span class="kwa">val</span> <span class="kwb">mutable</span> title = &quot;no title&quot;
    <span class="kwa">method</span> <span class="ocaml-function">set_title</span> <span class="ocaml-variable">t </span>= title &lt;- t
    <span class="kwa">method</span> <span class="ocaml-function">title</span><span class="ocaml-ty"></span> = title

    <span class="ocaml-comment">(* ... *)</span>
  <span class="kwa">end</span></span></pre>

<p>The object is going to contain a mutable member, the title, and two methods to <code>set_title</code> and get <code>title</code>.</p>
<p>Now we come to the repaint method, which is the guts of the widget. This draws the graph in the drawing area:</p>
<pre><span class="listing">&nbsp;   <span class="ocaml-comment">(* Repaint the widget. *)</span>
    <span class="kwa">method</span> <span class="ocaml-function">private</span> <span class="ocaml-variable">repaint () </span>=
      <span class="kwa">let </span><span class="ocaml-variable">drawable</span> = <span class="ocaml-mod">Lazy</span>.force drawable <span class="kwa">in</span>
      let (width, height) = drawable#size <span class="kwa">in</span>
      drawable#set_background `WHITE;
      drawable#set_foreground `WHITE;
      drawable#rectangle ~x:0 ~y:0 ~width ~height ~filled:true ();
      drawable#set_foreground `BLACK;

      <span class="ocaml-comment">(* Draw the title. *)</span>
      draw_text drawable font `Centre (width/2, 20) title;

      <span class="ocaml-comment">(* Draw the axes. *)</span>
      drawable#line ~x:40 ~y:(height-40) ~x:(width-40) ~y:(height-40);
      drawable#line ~x:40 ~y:(height-40) ~x:40 ~y:40;

      <span class="ocaml-comment">(* Which part <span class="kwb">of</span> the data <span class="kwb">to</span> display? first .. first+page_size-1 *)</span>
      <span class="kwa">let </span><span class="ocaml-variable">first_bar</span> = int_of_float adjustment#value <span class="kwa">in</span>
      <span class="kwa">let </span><span class="ocaml-variable">data</span> = <span class="ocaml-mod">Array</span>.sub array first_bar page_size <span class="kwa">in</span>
      <span class="kwa">let </span><span class="ocaml-variable">bar_width</span> = (width - 80) / page_size <span class="kwa">in</span>

      <span class="ocaml-comment">(* Compute function mapping graph (x, y) <span class="kwb">to</span> screen coordinates. *)</span>
      let map (x,y) =
        (40 + x * bar_width, height-40 - y * (height-80) / max_y)  <span class="kwa">in</span>

      <span class="ocaml-comment">(* Draw the axes scales. *)</span>
      draw_text drawable font `Right (40, height-40) &quot;0&quot;;
      draw_text drawable font `Right (40, 40) (string_of_int max_y);
      <span class="kwb">for</span> i = 0 <span class="kwb">to</span> page_size-1 <span class="kwb">do</span>
        <span class="kwa">let </span><span class="ocaml-variable">x</span> = 40 + i * bar_width + bar_width/2 <span class="kwa">in</span>
        <span class="kwa">let </span><span class="ocaml-variable">y</span> = height-35 <span class="kwa">in</span>
        <span class="kwa">let </span><span class="ocaml-variable">v</span> = first_bar + i <span class="kwa">in</span>
        draw_text drawable font `Centre (x, y) (string_of_int v)
      <span class="kwb">done</span>;

      <span class="ocaml-comment">(* Draw the data. *)</span>
      <span class="kwb">for</span> i = 0 <span class="kwb">to</span> page_size-1 <span class="kwb">do</span>
        let (ll_x,ll_y) = map (i, data.(i)) <span class="kwa">in</span>
        let (tr_x,tr_y) = map (i+1, 0) <span class="kwa">in</span>
        draw_rectangle drawable &quot;red&quot; (ll_x, ll_y) (tr_x, tr_y)
      <span class="kwb">done</span></span></pre>

<p>Apart from the calculation of screen coordinates from graph coordinates, the <code>repaint</code> method is essentially very simple. The Gtk drawing area contains a <code>drawable</code> object, and we use methods on this object such as <code>drawable#line</code> plus some helper functions which I haven't reproduced here to draw in the drawing area. It's really just a matter of calculating what to draw, where. Notice how we freely access let-bindings made before <code>object (self)</code>, eg. <code>page_size</code>, <code>drawable</code>, <code>adjustment</code>. These let-bindings are available in any method in the object.</p>
<p>The complete code for the graph is available in &lt;a href=&quot;graph.ml&quot;&gt;graph.ml&lt;/a&gt; and &lt;a href=&quot;test.ml&quot;&gt;test.ml&lt;/a&gt;. Compile it using:</p>
<pre>
ocamlc -g -w s -I +lablgtk lablgtk.cma gtkInit.cmo graph.ml test.ml -o graphtest
</pre>

<p>Here is a screenshot:</p>
<p>&lt;img src=&quot;graphtest.gif&quot; width=&quot;648&quot; height=&quot;508&quot; alt=&quot;Screenshot&quot;/&gt;</p>


<h3>Structure of lablgtk</h3>
<p>The lablgtk library has two layers, which I'm going to call the <em>module layer</em> and the <em>object-oriented layer</em> (plus some ancillary library modules which we'll also talk about). The layers are arranged like this in relation to your code:</p>
    <table class="structure_table">
      <tr><td colspan="2"> Your code </td></tr>
      <tr><td> Object-oriented layer </td> <td>eg. gButton.ml</td></tr>
      <tr><td> Module layer </td> <td>eg. gtkButton.ml<br/>ml_gtkbutton.c</td></tr>
      <tr><td colspan="2"> Gtk+ library (or DLL on Windows) </td></tr>
    </table>
<p>In theory you only need to interact with the object-oriented layer, and the theory is indeed true for trivial programs. However for practical purposes you will need to understand how the library is built up from these layers (and why).</p>

<h4>Gtk objects</h4>
<p>We'll start with the peculiarities of Gtk itself. This library is written in C and uses macros and &quot;clever&quot; hacks to (a) present an OO-ish interface and (b) perform simple garbage collection through reference counting. Part of the reason why lablgtk uses quite a complex model is to cater for the implementation of Gtk itself.</p>
<p>All &quot;objects&quot; in the Gtk library (I'll call them objects, but in reality they're C <code>struct</code>s) are &quot;derived&quot; from <code>GtkObject</code>. This means that an object such as a button contains within its <code>struct</code> a <code>struct _GtkObject</code>. This &quot;base class&quot; contains, amongst other things, a reference count which is used to provide simple garbage collection.</p>
<p>Of course, the above is all in the context of a C library for C programmers. OCaml has other mechanisms for OO and contains an advanced garbage collector. How does lablgtk unify the two?</p>
<p>Lablgtk starts with this type definition (in module <code>Gtk</code>):</p>
<pre>
type 'a obj;;
</pre>

<p>On the face of it, this is a <em>very</em> strange type definition. It defines a polymorphic type called <code>obj</code> (polymorphic because you can create, say, <code>int obj</code>, etc.). But it doesn't actually define a way of creating these objects! [Recall that a normal type definition might be something like this:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">type</span> 'a <span class="ocaml-mod">obj</span> = Something <span class="kwb">of</span> 'a</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>type 'a obj = Something of 'a
</span></pre>

<p>which gives you a very definite way to create, say, an <code>int obj</code>:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">Something 1</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int obj = Something 1
</span></pre>

<p>But our strange, bare definition just says:</p>
<pre><span class="listing"><span class="kwa">type</span> 'a obj;;</span></pre>

<p>How do we create objects of this type? The answer is that we don't. Instances of type <code>'a obj</code> are <code>GtkObject</code> structures (actually, more likely they are &quot;subclasses&quot; of <code>GtkObject</code>), and they are created by the C library. What precisely happens is that the C functions in the Gtk+ library are wrapped up by C functions which are called from OCaml. These functions look like this:</p>
<pre>
CAMLprim value
ml_gtk_toggle_button_new (value unit)
{
  return Val_GtkObject_sink ((GtkObject *) gtk_toggle_button_new ());
}
</pre>

<p><code>Val_GtkObject_sink</code> is a very complex little function which wraps up the <code>GtkObject</code> returned from the Gtk+ library function <code>gtk_toggle_button_new ()</code> in something that OCaml's garbage collector can understand. The same function also deals with Gtk's reference counting.</p>
<pre>
static void ml_final_GtkObject_sink (value val) {
  if (Field(val,1))
    gtk_object_unref ((GtkObject*)Field(val,1));
}

value Val_GtkObject_sink (GtkObject *p) {
  value ret;
  if (!p) ml_raise_null_pointer ();
  ret = alloc_final (2, ml_final_GtkObject_sink, 20, 1000);
  initialize (&amp;Field(ret,1), (value) p);
  gtk_object_ref_and_sink(p);
  return ret;
}
</pre>
<p>OCaml code calls <code>ml_gtk_toggle_button_new</code> directly to create objects of type <code>'a obj</code>.  Module <code>GtkButton</code> is in lablgtk's module layer and it contains an inner module called <code>GtkButton.ToggleButton</code> containing a function defined as:</p>
<pre><span class="listing"><span class="kwa">module</span> <span class="ocaml-mod">ToggleButton</span> <span class="ocaml-variable"></span>= <span class="kwa">struct</span>
  <span class="kwa">external</span> <span class="ocaml-function">toggle_button_create</span>&nbsp;: unit -&gt; toggle_button obj
      = &quot;ml_gtk_toggle_button_new&quot;
  <span class="kwa">external</span> <span class="ocaml-function">toggle_button_create_with_label</span>&nbsp;: string -&gt; toggle_button obj
      = &quot;ml_gtk_toggle_button_new_with_label&quot;
  <span class="kwa">let</span> <span class="ocaml-function">create_toggle</span> <span class="ocaml-variable">?label () </span>=
    <span class="kwb">match</span> label <span class="kwb">with</span>
    | None -&gt; toggle_button_create ()
    | Some label -&gt; toggle_button_create_with_label label
<span class="kwa">end</span></span></pre>

<p>You can call these functions directly to see what they return:</p>
<pre>
# GtkButton.ToggleButton.toggle_button_create ();;
- : Gtk.toggle_button Gtk.obj = &lt;abstr&gt;
# GtkButton.ToggleButton.create_toggle ~label:&quot;Push me!&quot; ();;
- : Gtk.toggle_button Gtk.obj = &lt;abstr&gt;
</pre>

<p>Notice the return type: <code>toggle_button obj</code> (ie. a definite instance of the polymorphic type <code>'a obj</code>). What is <code>toggle_button</code>? It's a type (think <code>'a list</code> vs. <code>int list</code>) defined like this (in module <code>Gtk</code>):</p>
<pre><span class="listing"><span class="kwa">type</span> <span class="ocaml-mod">widget</span> = [`base|`widget]
<span class="kwa">type</span> <span class="ocaml-mod">container</span> = [widget|`container]
<span class="kwa">type</span> <span class="ocaml-mod">button</span> = [container|`button]
<span class="kwa">type</span> <span class="ocaml-mod">toggle_button</span> = [button|`toggle]</span></pre>

<p>Hence the full type written out is:</p>
<pre><span class="listing"><span class="kwa">type</span> <span class="ocaml-mod">toggle_button</span> = [`base|`widget|`container|`button|`toggle]</span></pre>

<p>(These are polymorphic variants - see &lt;a href=&quot;../ch7/&quot;&gt;Chapter 7&lt;/a&gt; if you don't remember them).</p>
<p>If you check the Gtk class hierarchy you'll see that the list of variants closely (but not exactly) matches the classes. A Gtk toggle button is-a Gtk button, Gtk container is-a Gtk widget, etc.</p>

<h4>Object-oriented layer</h4>
<p>Now let's look at the object-oriented layer interface to the toggle button, so we can see how <code>'a obj</code> comes into play. The <code>GButton</code> module defines a class for toggle buttons, but unusually you don't directly create instances of this class using <code>new toggle_button</code> (or similar). Instead a function is provided which generates instances for you. Here it is, simplified somewhat:</p>
<pre><span class="listing"><span class="kwa">let</span> <span class="ocaml-function">toggle_button</span> <span class="ocaml-variable">?label ?border_width ?width ?height () </span>=
  <span class="kwa">let </span><span class="ocaml-variable">w</span> = <span class="ocaml-mod">ToggleButton</span>.create_toggle ?label () <span class="kwa">in</span>
  <span class="ocaml-mod">Container</span>.set w ?border_width ?width ?height;
  <span class="kwb">new</span> toggle_button w</span></pre>

<p>Recall that <code>w</code> has the abstract type <code>[`base|`widget|`container|`button|`toggle] obj</code>, and it wraps up the actual <code>GtkObject</code> allocated by the C library.</p>
<p>A toggle button is-a container, and the next thing we do is call <code>Container.set</code> to set some properties in the base class. Here is where the polymorphic variants become interesting. What is the type of <code>Container.set</code>?</p>
<pre><span class="listing"># <span class="ocaml-mod">GtkBase</span>.<span class="ocaml-mod">Container</span>.set;;
- : ?border_width:int -&gt;
    ?width:int -&gt; ?height:int -&gt; [&gt; `container | `widget] <span class="ocaml-mod">Gtk</span>.obj -&gt; unit
= &lt;<span class="kwb">fun</span>&gt;</span></pre>

<p><code>Container.set</code> is expecting an argument of type <code>[&gt;`container|`widget] obj</code>. Recall from our discussion of polymorphic variants that <code>[&gt;`container|`widget]</code> means &quot;a variant which contains <em>at least</em> <code>`container</code> and <code>`widget</code>, and possibly other things too&quot;. Now go back and compare with the definition of <code>toggle_button</code> type above.</p>
<p>So <code>w</code> of type <code>[`base|`widget|`container|`button|`toggle] obj</code> is compatible with the call to <code>Container.set</code>, expecting <code>[&gt;`container|`widget] obj</code>.</p>
<p>Finally our function actually creates the class, passing the widget <code>w</code> as the parameter to the class. The class is defined like this (simplified):</p>
<pre><span class="listing"><span class="kwa">class</span> <span class="ocaml-function">toggle_button</span> <span class="ocaml-variable">w </span>= <span class="kwa">object</span>
  <span class="kwa">inherit</span> button w
  <span class="kwa">method</span> <span class="ocaml-function">connect</span><span class="ocaml-ty"></span> = <span class="kwb">new</span> toggle_button_signals obj
  <span class="kwa">method</span> <span class="ocaml-function">active</span><span class="ocaml-ty"></span> = <span class="ocaml-mod">ToggleButton</span>.get_active obj
  <span class="kwa">method</span> <span class="ocaml-function">set_active</span><span class="ocaml-ty"></span> = <span class="ocaml-mod">ToggleButton</span>.set_active obj
  <span class="kwa">method</span> <span class="ocaml-function">set_draw_indicator</span><span class="ocaml-ty"></span> = <span class="ocaml-mod">ToggleButton</span>.set_mode obj
<span class="kwa">end</span></span></pre>

<p>The base class for all objects is <code>GObj.gtkobj</code> defined as:</p>
<pre><span class="listing"><span class="kwa">class</span> <span class="ocaml-function">gtkobj</span> <span class="ocaml-variable">w </span>= <span class="kwa">object</span>
  <span class="kwa"><span class="kwa">val</span></span> <span class="ocaml-variable">obj</span> = w
  <span class="kwa">method</span> <span class="ocaml-function">destroy</span> <span class="ocaml-variable">() </span>= <span class="ocaml-mod">Object</span>.destroy w
  <span class="kwa">method</span> <span class="ocaml-function">get_id</span><span class="ocaml-ty"></span> = <span class="ocaml-mod">Object</span>.get_id w
<span class="kwa">end</span></span></pre>

<p>So all classes, including <code>toggle_button</code>, have access to their underlying object (the <code>GtkObject</code> allocated in C) through the <code>obj</code> member, and have <code>#destroy</code> and <code>#get_id</code> methods. All classes derived from <code>widget</code> have a public <code>#as_widget</code> method which returns the underlying object (sadly there is no equivalent for <code>gtkobj</code>, although this doesn't matter so much since almost all interesting classes are widgets).</p>
<p>Let's try the OO interface for toggle buttons:</p>
<pre><span class="listing"><span class="ocaml-comment">(* call the toggle_button function *)</span>
# <span class="kwa">let </span><span class="ocaml-variable">b</span> = <span class="ocaml-mod">GButton</span>.toggle_button ~label:&quot;Push me!&quot; ();;
          <span class="ocaml-comment">(* note: returns <span class="kwa">object</span> from toggle_button class *)</span>
<span class="kwa"><span class="kwa">val</span></span> <span class="ocaml-function">b</span> : <span class="ocaml-mod">GButton</span>.toggle_button = &lt;obj&gt;
# b#as_widget;;
          <span class="ocaml-comment">(* note: returns a widget obj == [`base|`widget] obj *)</span>
- : <span class="ocaml-mod">Gtk</span>.widget <span class="ocaml-mod">Gtk</span>.obj = &lt;abstr&gt;</span></pre>

<h4>Downcasts</h4>
<p>Gtk is dynamically typed, and this means you can &lt;dfn&gt;downcast&lt;/dfn&gt;, for example, a widget into a toggle button. Gtk requires downcasting in some instances: for example you can pack widgets into containers, but if you try and retrieve them out of the container, all you get is a list of widgets.  The original type of the widgets is lost. Assuming you know that a widget is really, say, a button, then Gtk requires you to downcast the widget to a button in order to use the button-like features.</p>
<p>Such an operation is normally illegal in OCaml because OCaml is strongly typed at compile time and downcasting is unsafe. The widget might or might not actually be a toggle button.  Lablgtk allows downcasting, and provides another mechanism for casting which avoids the explicit downcast. Whichever way you do it, you may get a runtime exception if you cast to the wrong type.</p>
<p>The simplest downcast is just to unwrap the <code>'a obj</code> (<code>GtkObject</code>) from one class and wrap it in another class. Here we take the children out of a table widget, which we happen to know are actually all vboxes, unwrap each one from the <code>widget</code> class and rewrap in a <code>GPack.box</code> class.  (Example due to Jacques Garrigue.)</p>
<pre><span class="listing"><span class="kwa">let</span> <span class="ocaml-function">vbox_of_widget</span> <span class="ocaml-variable">widget </span>=
  <span class="kwa">let </span><span class="ocaml-variable">obj</span> = <span class="ocaml-mod">GtkPack</span>.<span class="ocaml-mod">Box</span>.cast widget#as_widget <span class="kwa">in</span>
  <span class="kwb">new</span> <span class="ocaml-mod">GPack</span>.box obj

<span class="kwa">let </span><span class="ocaml-variable">vboxes</span> = <span class="ocaml-mod">List</span>.iter vbox_of_widget table#children</span></pre>

<p>The terminology might be a little bit confusing here because the <code>#as_widget</code> method returns the internal <code>GtkObject</code> of type <code>'a obj</code>.</p>
<p><code>GtkPack.Box.cast</code> does the actual unsafe downcast. Downcasts can always fail at runtime, and in the case above the <code>Cannot_cast</code> exception could be thrown. You should be prepared to deal with this - unfortunately it's a program bug which cannot be picked up at compile time.</p>
<p>The other method for doing this avoids the explicit downcast, but can still throw an exception indicating a program bug at runtime. The strategy here is to remember what objects we put into the container separately, and when we take them out try to match them up. We use the <code>GUtil.memo</code> class for this:</p>
<pre><span class="listing">class ['a] memo () = <span class="kwa">object</span>
  constraint 'a = #widget
  <span class="kwa"><span class="kwa">val</span></span> <span class="ocaml-variable">tbl</span> = <span class="ocaml-mod">Hashtbl</span>.create 7
  <span class="kwa">method</span> <span class="ocaml-function">add</span> <span class="ocaml-variable">(obj : 'a) </span>=
    <span class="ocaml-mod">Hashtbl</span>.add tbl obj#get_id obj
  <span class="kwa">method</span> <span class="ocaml-function">find</span> <span class="ocaml-variable">(obj : widget) </span>= <span class="ocaml-mod">Hashtbl</span>.find tbl obj#get_id
  <span class="kwa">method</span> <span class="ocaml-function">remove</span> <span class="ocaml-variable">(obj : widget) </span>= <span class="ocaml-mod">Hashtbl</span>.remove tbl obj#get_id
<span class="kwa">end</span></span></pre>

<p>(The constraint essentially says that <code>'a</code> must be a widget, or some subclass of widget).</p>
<p>Here is an example of using a memo. First we will create a top-level window, a container (vbox) to go inside this, and a button:</p>
<pre><span class="listing"># <span class="kwa">let </span><span class="ocaml-variable">w</span> = <span class="ocaml-mod">GWindow</span>.window ();;
<span class="kwa"><span class="kwa">val</span></span> <span class="ocaml-function">w</span> : <span class="ocaml-mod">GWindow</span>.window = &lt;obj&gt;
# <span class="kwa">let </span><span class="ocaml-variable">c</span> = <span class="ocaml-mod">GPack</span>.vbox ~packing:w#add ();;
<span class="kwa"><span class="kwa">val</span></span> <span class="ocaml-function">c</span> : <span class="ocaml-mod">GPack</span>.box = &lt;obj&gt;
# <span class="kwa">let </span><span class="ocaml-variable">b</span> = <span class="ocaml-mod">GButton</span>.button ~label:&quot;Push me!&quot; ();;
<span class="kwa"><span class="kwa">val</span></span> <span class="ocaml-function">b</span> : <span class="ocaml-mod">GButton</span>.button = &lt;obj&gt;</span></pre>

<p>Before we pack the button into the container, let's create a memo to remember the real object. Notice how the type of the memo is refined as soon as the button is added:</p>
<pre><span class="listing"># <span class="kwa">let </span><span class="ocaml-variable">m</span> = <span class="kwb">new</span> <span class="ocaml-mod">GUtil</span>.memo ();;
<span class="kwa"><span class="kwa">val</span></span> <span class="ocaml-function">m</span> : _#<span class="ocaml-mod">GObj</span>.widget <span class="ocaml-mod">GUtil</span>.memo = &lt;obj&gt;
# m#add b;;
- : unit = ()
# m;;
- : <span class="ocaml-mod">GButton</span>.button <span class="ocaml-mod">GUtil</span>.memo = &lt;obj&gt;</span></pre>

<p>Now we can add the button to the container, remembering to upcast it to a widget first of course:</p>
<pre><span class="listing"># c#add (b :&gt; <span class="ocaml-mod">GObj</span>.widget);;
- : unit = ()</span></pre>

<p>The method <code>#children</code> returns a list of widgets. Not much use to us:</p>
<pre><span class="listing"># c#children;;
- : <span class="ocaml-mod">GObj</span>.widget list = [&lt;obj&gt;]</span></pre>

<p>But we can use our memo to map these widgets to the original button objects:</p>
<pre><span class="listing"># <span class="ocaml-mod">List</span>.map (<span class="kwb">fun</span> w -&gt; m#find w) c#children;;
- : <span class="ocaml-mod">GButton</span>.button list = [&lt;obj&gt;]</span></pre>

<p>Remember that this is still dynamic casting, and so unsafe. In this case the memo will throw a <code>Not_found</code> exception if the widget cannot be mapped:</p>
<pre><span class="listing"># <span class="kwa">let </span><span class="ocaml-variable">b2</span> = <span class="ocaml-mod">GButton</span>.button ~label:&quot;Don't push me!&quot; ();;
<span class="kwa"><span class="kwa">val</span></span> <span class="ocaml-function">b2</span> : <span class="ocaml-mod">GButton</span>.button = &lt;obj&gt;
# c#add (b2 :&gt; <span class="ocaml-mod">GObj</span>.widget);;
- : unit = ()
# <span class="ocaml-mod">List</span>.map (<span class="kwb">fun</span> w -&gt; m#find w) c#children;;
Exception: <span class="ocaml-mod">Not_found</span>.</span></pre>

<h3>Structure of lablgtk â€” summary</h3>
<ul><li><code>GtkObject</code>s allocated by the C library are wrapped up in opaque <code>'a obj</code> abstract types.</li>
<li>The module layer is flat (not OO) but uses polymorphic variants to simulate a class hierarchy.</li>
<li>The module layer handles Gtk's reference counting for you transparently. </li>
<li>Classes in the OO layer store the opaque <code>GtkObject</code> in a member called <code>obj</code>, and perform operations through the module layer, usually passing <code>obj</code> as the first parameter. </li>
<li>Helper functions are provided to create instances of classes.</li>
<li>Lablgtk provides two ways to perform downcasting, but this doesn't change the fact that downcasting is unsafe and can throw exceptions at runtime.</li></ul>
<p>&lt;a href=&quot;../ch13/&quot;&gt;Chapter 13&lt;/a&gt; continues with a discussion of wrapping up external C libraries. We look at another way to wrap up Gtk.</p>




    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-37808023-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script>

</body></html>

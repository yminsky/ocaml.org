<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: 99 Problems (solved) in OCaml</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contributors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="99 Problems (solved) in OCaml" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
    <li><a href="../papers.html">Papers</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../releases/latest.html">Releases</a></li>
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development Tools</a></li>
    <li><a href="../books.html#manual">User Manual</a></li>
    <li><a href="../cheat_sheets.html">Cheat Sheets</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">GitHub</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../planet/">Blogs</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span><a href="./">Tutorials</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>99 Problems (solved) in OCaml
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <div class="disclaimer">
      <strong>Your Help is Needed</strong><br/>
      <small>Many of the solutions below have been written
	by <a href="https://github.com/VictorNicollet/99-Problems-OCaml">Victor Nicollet</a>.  Please contribute more solutions or
	improve the existing ones.</small>
    </div>

    <div style="margin-left: 1em" class="pull-right hero-unit">
      <em>Table of contents</em>
      <div class="toc"><ul class="toc-sub"><li class="toc-entry"><a href="#list">Working with lists</a></li><li class="toc-entry"><a href="#arithmetic">Arithmetic</a></li><li class="toc-entry"><a href="#logic">Logic and Codes</a></li><li class="toc-entry"><a href="#bin-tree">Binary Trees</a></li><li class="toc-entry"><a href="#mult-tree">Multiway Trees</a></li><li class="toc-entry"><a href="#graphs">Graphs</a></li><li class="toc-entry"><a href="#misc">Miscellaneous Problems</a></li></ul></div>
    </div>

    <h1>99 Problems (solved) in OCaml</h1>

    <p>This section is inspired
      by <a href="http://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html">Ninety-Nine Lisp Problems</a> which in turn was based on
      “<a href="https://sites.google.com/site/prologsite/prolog-problems/"> Prolog
	problem list</a>”.  For each of these questions, some simple tests are
      shown—they may also serve to make the question clearer if needed.
      To work on these problems, we recommend you
      first <a href="../install.html">install OCaml</a> or use it
      <a target="_blank" href="http://try.ocamlpro.com/">inside your
      browser</a>. The source of the following problems is available
      on <a href="https://github.com/VictorNicollet/99-Problems-OCaml">GitHub</a>.
    </p>


<script type="text/javascript">
function toggleContent(id) {
  // Get the DOM reference
  var q = document.getElementById(id);
  // Toggle
  solution = new RegExp("(^|\\s)solution(\\s|$)");
  var els = q.getElementsByTagName("*");
  for (var i = 0; i < els.length; i++) {
    if (els[i].tagName.toLowerCase() != "button"
        && solution.test(els[i].getAttribute("class"))) {
      els[i].style.display == "block" ? els[i].style.display = "none"
                                      : els[i].style.display = "block";
    }
  }
}
</script>

<h2><a name="list"></a>Working with lists</h2>

<div id="q1" class="question easy">
  <div class="title">Write a function <code>last : 'a list -> 'a
      option</code> that returns the last element of a list.</div>
  <button class="solution" onclick="toggleContent('q1')">Solution</button>

<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">last</span> = <span class="kwb">function</span>
    | [] -&gt; None
    | [x] -&gt; Some x
    | _ :: t -&gt; last t</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val last : 'a list -&gt; 'a option = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">last [ `a ; `b ; `c ; `d ] = Some `d</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">last [] = None</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q2" class="question easy">
  <div class="title">Find the last but one (last and penultimate)
    elements of a list.</div>
  <button class="solution" onclick="toggleContent('q2')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">last_two</span> = <span class="kwb">function</span>
    | [] | [_] -&gt; None
    | [x;y] -&gt; Some (x,y)
    | _::t -&gt; last_two t</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val last_two : 'a list -&gt; ('a * 'a) option = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">last_two [ `a ; `b ; `c ; `d ] = Some (`c,`d)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">last_two [ `a ] = None</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q3" class="question easy">
  <div class="title">Find the <code>k</code>'th element of a list.</div>
  <button class="solution" onclick="toggleContent('q3')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">at</span> <span class="ocaml-variable">k </span>= <span class="kwb">function</span>
    | [] -&gt; None
    | h :: t -&gt; <span class="kwb">if</span> k = 1 <span class="kwb">then</span> Some h <span class="kwb">else</span> at (k-1) t</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val at : int -&gt; 'a list -&gt; 'a option = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">at 3 [ `a ; `b ; `c ; `d ; `e ] = Some `c</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">at 3 [ `a ] = None</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q4" class="question easy">
  <div class="title">Find the number of elements of a list.</div>
  <p>OCaml standard library has <code>List.length</code> but we ask
    that you reimplement it.  Bonus for a
    <a href="http://en.wikipedia.org/wiki/Tail_call">tail
    recursive</a> solution.</p>
  <button class="solution" onclick="toggleContent('q4')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* This function is tail-recursive: it uses a constant amount <span class="kwb">of</span>
     stack memory regardless <span class="kwb">of</span> list size. *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">length</span> <span class="ocaml-variable">list </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">n </span>= <span class="kwb">function</span>
      | [] -&gt; n
      | _::t -&gt; aux (n+1) t
    <span class="kwa">in</span> aux 0 list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val length : 'a list -&gt; int = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">length [ `a ; `b ; `c] = 3</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">length [] = 0</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q5" class="question easy">
  <div class="title">Reverse a list.</div>
  <p>OCaml standard library has <code>List.rev</code> but we ask
    that you reimplement it.</p>
  <button class="solution" onclick="toggleContent('q5')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">rev</span> <span class="ocaml-variable">list </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">acc </span>= <span class="kwb">function</span>
      | [] -&gt; acc
      | h::t -&gt; aux (h::acc) t <span class="kwa">in</span>
    aux [] list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val rev : 'a list -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">rev [`a ; `b ; `c] = [`c ; `b ; `a]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q6" class="question easy">
  <div class="title">Find out whether a list is a palindrome.</div>
  <p> HINT: a palindrome is its own reverse.</p>
  <button class="solution" onclick="toggleContent('q6')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">is_palindrome</span> <span class="ocaml-variable">list </span>=
    list = <span class="ocaml-mod">List</span>.rev list
  <span class="ocaml-comment">(* One can use either the rev function from the previous problem, or the
     built-<span class="kwa">in</span> <span class="ocaml-mod">List</span>.rev *)</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val is_palindrome : 'a list -&gt; bool = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">is_palindrome [ `x ; `a ; `m ; `a ; `x ]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">not (is_palindrome [ `a ; `b ])</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q7" class="question medium">
  <div class="title">Flatten a nested list structure.</div>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* There is no nested list <span class="kwa">type</span> <span class="kwa">in</span> OCaml, so we need <span class="kwb">to</span> define one
     first. A node <span class="kwb">of</span> a nested list is either an element, or a list <span class="kwb">of</span>
     nodes. *)</span>
  <span class="kwa">type</span> 'a <span class="ocaml-mod">node</span> =
    | One <span class="kwb">of</span> 'a
    | Many <span class="kwb">of</span> 'a node list</span><span class="ocamltop-prompt">;;</span></pre>
<button class="solution" onclick="toggleContent('q7')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* This function traverses the list, prepending any encountered elements
    <span class="kwb">to</span> an accumulator, which flattens the list <span class="kwa">in</span> inverse order. It can
    <span class="kwb">then</span> be reversed <span class="kwb">to</span> obtain the actual flattened list. *)</span>

  <span class="kwa">let</span> <span class="ocaml-function">flatten</span> <span class="ocaml-variable">list </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">acc </span>= <span class="kwb">function</span>
      | [] -&gt; acc
      | One x :: t -&gt; aux (x :: acc) t
      | Many l :: t -&gt; aux (aux acc l) t <span class="kwa">in</span>
    <span class="ocaml-mod">List</span>.rev (aux [] list)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val flatten : 'a node list -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">flatten [ One `a ; Many [ One `b ; Many [ One `c ; One `d ] ; One `e ] ]
  = [ `a ; `b ; `c ; `d ; `e ]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q8" class="question medium">
  <div class="title">Eliminate consecutive duplicates of list
    elements.</div>
  <button class="solution" onclick="toggleContent('q8')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">compress</span> = <span class="kwb">function</span>
    | a :: (b :: _ <span class="kwb">as</span> t) -&gt; <span class="kwb">if</span> a = b <span class="kwb">then</span> compress t <span class="kwb">else</span> a :: compress t
    | smaller -&gt; smaller</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val compress : 'a list -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">compress [`a;`a;`a;`a;`b;`c;`c;`a;`a;`d;`e;`e;`e;`e] = [`a;`b;`c;`a;`d;`e]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q9" class="question medium"><a name="pack"></a>
  <div class="title">Pack consecutive duplicates
    of list elements into sublists.</div>
  <button class="solution" onclick="toggleContent('q9')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">pack</span> <span class="ocaml-variable">list </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">current acc </span>= <span class="kwb">function</span>
      | [] -&gt; []    <span class="ocaml-comment">(* Can only be reached <span class="kwb">if</span> original list is empty *)</span>
      | [x] -&gt; (x :: current) :: acc
      | a :: (b :: _ <span class="kwb">as</span> t) -&gt;
         <span class="kwb">if</span> a = b <span class="kwb">then</span> aux (a :: current) acc t
         <span class="kwb">else</span> aux [] ((a :: current) :: acc) t  <span class="kwa">in</span>
    <span class="ocaml-mod">List</span>.rev (aux [] [] list)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val pack : 'a list -&gt; 'a list list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">pack [`a;`a;`a;`a;`b;`c;`c;`a;`a;`d;`d;`e;`e;`e;`e]
  = [[`a;`a;`a;`a]; [`b]; [`c;`c]; [`a;`a]; [`d;`d]; [`e;`e;`e;`e]]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>


<div id="q10" class="question easy">
  <div class="title"><a target="_blank" href="http://en.wikipedia.org/wiki/Run-length_encoding">Run-length encoding</a>
    of a list.</div>
  <button class="solution" onclick="toggleContent('q10')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">encode</span> <span class="ocaml-variable">list </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">count acc </span>= <span class="kwb">function</span>
      | [] -&gt; [] <span class="ocaml-comment">(* Can only be reached <span class="kwb">if</span> original list is empty *)</span>
      | [x] -&gt; (count+1, x) :: acc
      | a :: (b :: _ <span class="kwb">as</span> t) -&gt; <span class="kwb">if</span> a = b <span class="kwb">then</span> aux (count + 1) acc t
                              <span class="kwb">else</span> aux 0 ((count+1,a) :: acc) t   <span class="kwa">in</span>
    <span class="ocaml-mod">List</span>.rev (aux 0 [] list)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val encode : 'a list -&gt; (int * 'a) list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">encode [`a;`a;`a;`a;`b;`c;`c;`a;`a;`d;`e;`e;`e;`e]
  = [4,`a ; 1,`b ; 2,`c ; 2,`a ; 1,`d ; 4,`e]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q11" class="question easy"><a name="modif-run-length"></a>
  <div class="title">Modified run-length encoding.</div>
  <p>Modify the result of the previous problem in such a way that if
    an element has no duplicates it is simply copied into the result
    list.  Only elements with duplicates are transferred as (N E)
    lists.</p>
  <p>Since OCaml lists are homogeneous, one needs to define a type
    to hold both single elements and sub-lists.</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">type</span> 'a <span class="ocaml-mod">rle</span> =
    | One <span class="kwb">of</span> 'a
    | Many <span class="kwb">of</span> (int * 'a)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>type 'a rle = One of 'a | Many of (int * 'a)
</span></pre>
<button class="solution" onclick="toggleContent('q11')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">pack</span> <span class="ocaml-variable">list </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">current acc </span>= <span class="kwb">function</span>
      | [] -&gt; [] <span class="ocaml-comment">(* Can only be reached <span class="kwb">if</span> original list is empty *)</span>
      | [x] -&gt; (x :: current) :: acc
      | a :: (b :: _ <span class="kwb">as</span> t) -&gt; <span class="kwb">if</span> a = b <span class="kwb">then</span> aux (a :: current) acc t
                              <span class="kwb">else</span> aux [] ((a :: current) :: acc) t  <span class="kwa">in</span>
    <span class="ocaml-mod">List</span>.rev (aux [] [] list)
  <span class="kwa">let</span> <span class="ocaml-function">encode</span> <span class="ocaml-variable">list </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> = <span class="kwb">function</span>
      | [] -&gt; []
      | [] :: t -&gt; aux t
      | [x] :: t -&gt; One x :: aux t
      | (x :: l) :: t -&gt; Many (1 + <span class="ocaml-mod">List</span>.length l , x) :: aux t  <span class="kwa">in</span>
    aux (pack list)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val pack : 'a list -&gt; 'a list list = &lt;fun&gt;
val encode : 'a list -&gt; 'a rle list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">encode [`a;`a;`a;`a;`b;`c;`c;`a;`a;`d;`e;`e;`e;`e]
  = [Many (4,`a) ; One `b ; Many (2,`c) ; Many (2,`a) ; One `d ; Many (4,`e)]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q12" class="question medium">
  <div class="title">Decode a run-length encoded list.</div>
  <p>Given a run-length code list generated as specified in the
    previous problem, construct its uncompressed version.</p>
  <button class="solution" onclick="toggleContent('q12')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">decode</span> <span class="ocaml-variable">list </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">many</span> <span class="ocaml-variable">acc n x </span>=
      <span class="kwb">if</span> n = 0 <span class="kwb">then</span> acc <span class="kwb">else</span> many (x :: acc) (n-1) x <span class="kwa">in</span>
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">acc </span>= <span class="kwb">function</span>
      | [] -&gt; acc
      | One x :: t -&gt; aux (x :: acc) t
      | Many (n,x) :: t -&gt; aux (many acc n x) t  <span class="kwa">in</span>
    aux [] (<span class="ocaml-mod">List</span>.rev list)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val decode : 'a rle list -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">decode [Many (4,`a); One `b; Many (2,`c); Many (2,`a); One `d; Many (4,`e)]
  = [`a;`a;`a;`a;`b;`c;`c;`a;`a;`d;`e;`e;`e;`e]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q13" class="question medium"><a name="run-length-direct"></a>
  <div class="title">Run-length encoding of a list (direct solution).</div>
  <p>Implement the so-called run-length encoding data compression
    method directly.  I.e.&nbsp;don't explicitly create the sublists
    containing the duplicates, as in problem “<a href="#pack">Pack
    consecutive duplicates of list elements into sublists</a>”, but
    only count them. As in problem
    “<a href="#modif-run-length">Modified run-length encoding</a>”,
    simplify the result list by replacing the singleton lists (1 X)
    by X.
  </p>
  <button class="solution" onclick="toggleContent('q13')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">encode</span> <span class="ocaml-variable">list </span>=
    <span class="kwa">let</span> <span class="ocaml-function">rle</span> <span class="ocaml-variable">count x </span>= <span class="kwb">if</span> count = 0 <span class="kwb">then</span> One x <span class="kwb">else</span> Many (count + 1, x) <span class="kwa">in</span>
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">count acc </span>= <span class="kwb">function</span>
      | [] -&gt; [] <span class="ocaml-comment">(* Can only be reached <span class="kwb">if</span> original list is empty *)</span>
      | [x] -&gt; rle count x :: acc
      | a :: (b :: _ <span class="kwb">as</span> t) -&gt; <span class="kwb">if</span> a = b <span class="kwb">then</span> aux (count + 1) acc t
                              <span class="kwb">else</span> aux 0 (rle count a :: acc) t   <span class="kwa">in</span>
    <span class="ocaml-mod">List</span>.rev (aux 0 [] list)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val encode : 'a list -&gt; 'a rle list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">encode [`a;`a;`a;`a;`b;`c;`c;`a;`a;`d;`e;`e;`e;`e] =
  [Many (4,`a); One `b; Many (2,`c); Many (2,`a); One `d; Many (4,`e)]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q14" class="question easy">
  <div class="title">Duplicate the elements of a list.</div>
  <button class="solution" onclick="toggleContent('q14')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">duplicate</span> = <span class="kwb">function</span>
    | [] -&gt; []
    | h :: t -&gt; h :: h :: duplicate t</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val duplicate : 'a list -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">duplicate [`a;`b;`c;`c;`d] = [`a;`a;`b;`b;`c;`c;`c;`c;`d;`d]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q15" class="question medium">
  <div class="title">Replicate the elements of a list a given number
    of times.</div>
  <button class="solution" onclick="toggleContent('q15')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">replicate</span> <span class="ocaml-variable">list n </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">prepend</span> <span class="ocaml-variable">n acc x </span>=
      <span class="kwb">if</span> n = 0 <span class="kwb">then</span> acc <span class="kwb">else</span> prepend (n-1) (x :: acc) x <span class="kwa">in</span>
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">acc </span>= <span class="kwb">function</span>
      | [] -&gt; acc
      | h :: t -&gt; aux (prepend n acc h) t  <span class="kwa">in</span>
    <span class="ocaml-comment">(* This could also be written <span class="kwb">as</span>:
       <span class="ocaml-mod">List</span>.fold_left (prepend n) [] (<span class="ocaml-mod">List</span>.rev list) *)</span>
    aux [] (<span class="ocaml-mod">List</span>.rev list)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val replicate : 'a list -&gt; int -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">replicate [`a;`b;`c] 3 = [`a;`a;`a;`b;`b;`b;`c;`c;`c]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q16" class="question medium">
  <div class="title">Drop every N'th element from a list.</div>
  <button class="solution" onclick="toggleContent('q16')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">drop</span> <span class="ocaml-variable">list n </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">i </span>= <span class="kwb">function</span>
      | [] -&gt; []
      | h :: t -&gt; <span class="kwb">if</span> i = n <span class="kwb">then</span> aux 1 t <span class="kwb">else</span> h :: aux (i+1) t  <span class="kwa">in</span>
    aux 1 list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val drop : 'a list -&gt; int -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">drop [`a;`b;`c;`d;`e;`f;`g;`h;`i;`j] 3 = [`a;`b;`d;`e;`g;`h;`j]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q17" class="question easy">
  <div class="title">Split a list into two parts; the length of the
    first part is given.</div>
  <p>If the length of the first part is longer than the entire list,
    then the first part is the list and the second part is
    empty.</p>
  <button class="solution" onclick="toggleContent('q17')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">split</span> <span class="ocaml-variable">list n </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">i acc </span>= <span class="kwb">function</span>
      | [] -&gt; <span class="ocaml-mod">List</span>.rev acc, []
      | h :: t <span class="kwb">as</span> l -&gt; <span class="kwb">if</span> i = 0 <span class="kwb">then</span> <span class="ocaml-mod">List</span>.rev acc, l
                       <span class="kwb">else</span> aux (i-1) (h :: acc) t  <span class="kwa">in</span>
    aux n [] list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val split : 'a list -&gt; int -&gt; 'a list * 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">split [`a;`b;`c;`d;`e;`f;`g;`h;`i;`j] 3
  = ([`a;`b;`c] , [`d;`e;`f;`g;`h;`i;`j])</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">split [`a;`b;`c;`d] 5 = ([`a; `b; `c; `d], [])</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q18" class="question medium">
  <div class="title">Extract a slice from a list.</div>
  <p>Given two indices, <code>i</code> and <code>k</code>, the slice
    is the list containing the elements between the <code>i</code>'th
    and <code>k</code>'th element of the original list (both limits
    included).  Start counting the elements with 0 (this is the
    way the <code>List</code> module numbers elements).</p>
  <button class="solution" onclick="toggleContent('q18')">Solution</button>
  <div class="solution">
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">slice</span> <span class="ocaml-variable">list i k </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">take</span> <span class="ocaml-variable">n </span>= <span class="kwb">function</span>
      | [] -&gt; []
      | h :: t -&gt; <span class="kwb">if</span> n = 0 <span class="kwb">then</span> [] <span class="kwb">else</span> h :: take (n-1) t
    <span class="kwa">in</span>
    <span class="kwa">let rec</span> <span class="ocaml-function">drop</span> <span class="ocaml-variable">n </span>= <span class="kwb">function</span>
      | [] -&gt; []
      | h :: t <span class="kwb">as</span> l -&gt; <span class="kwb">if</span> n = 0 <span class="kwb">then</span> l <span class="kwb">else</span> drop (n-1) t
    <span class="kwa">in</span>
    take (k - i + 1) (drop i list)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val slice : 'a list -&gt; int -&gt; int -&gt; 'a list = &lt;fun&gt;
</span></pre>
  </div>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">slice [`a;`b;`c;`d;`e;`f;`g;`h;`i;`j] 2 6 = [`c;`d;`e;`f;`g]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q19" class="question medium">
  <div class="title">Rotate a list N places to the left.</div>
  <button class="solution" onclick="toggleContent('q19')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">split</span> <span class="ocaml-variable">list n </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">i acc </span>= <span class="kwb">function</span>
      | [] -&gt; <span class="ocaml-mod">List</span>.rev acc, []
      | h :: t <span class="kwb">as</span> l -&gt; <span class="kwb">if</span> i = 0 <span class="kwb">then</span> <span class="ocaml-mod">List</span>.rev acc, l
                       <span class="kwb">else</span> aux (i-1) (h :: acc) t    <span class="kwa">in</span>
    aux n [] list

  <span class="kwa">let</span> <span class="ocaml-function">rotate</span> <span class="ocaml-variable">list n </span>=
    <span class="kwa">let </span><span class="ocaml-variable">len</span> = <span class="ocaml-mod">List</span>.length list <span class="kwa">in</span>
    <span class="ocaml-comment">(* Compute a rotation value between 0 and len-1 *)</span>
    <span class="kwa">let </span><span class="ocaml-variable">n</span> = <span class="kwb">if</span> len = 0 <span class="kwb">then</span> 0 <span class="kwb">else</span> (n mod len + len) mod len <span class="kwa">in</span>
    <span class="kwb">if</span> n = 0 <span class="kwb">then</span> list
    <span class="kwb">else</span> let a, b = split list n <span class="kwa">in</span> b @ a</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val split : 'a list -&gt; int -&gt; 'a list * 'a list = &lt;fun&gt;
val rotate : 'a list -&gt; int -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">rotate [`a;`b;`c;`d;`e;`f;`g;`h] 3 = [`d;`e;`f;`g;`h;`a;`b;`c]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">rotate [`a;`b;`c;`d;`e;`f;`g;`h] (-2) = [`g;`h;`a;`b;`c;`d;`e;`f]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q20" class="question easy">
  <div class="title">Remove the K'th element from a list.</div>
  <p>The first element of the list is numbered 0, the second 1,...</p>
  <button class="solution" onclick="toggleContent('q20')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">remove_at</span> <span class="ocaml-variable">n </span>= <span class="kwb">function</span>
    | [] -&gt; []
    | h :: t -&gt; <span class="kwb">if</span> n = 0 <span class="kwb">then</span> t <span class="kwb">else</span> h :: remove_at (n-1) t</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val remove_at : int -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">remove_at 1 [`a;`b;`c;`d] = [`a;`c;`d]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q21" class="question easy">
  <div class="title">Insert an element at a given position into a
    list.</div>
  <p>Start counting list elements with 0.</p>
  <button class="solution" onclick="toggleContent('q21')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">insert_at</span> <span class="ocaml-variable">x n </span>= <span class="kwb">function</span>
    | [] -&gt; []
    | h :: t <span class="kwb">as</span> l -&gt; <span class="kwb">if</span> n = 0 <span class="kwb">then</span> x :: l <span class="kwb">else</span> h :: insert_at x (n-1) t</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val insert_at : 'a -&gt; int -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">insert_at `alfa 1 [`a;`b;`c;`d] = [`a;`alfa;`b;`c;`d]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q22" class="question easy">
  <div class="title">Create a list containing all integers within a
    given range.</div>
  <p>If first argument is smaller than second, produce a list in
    decreasing order.</p>
  <button class="solution" onclick="toggleContent('q22')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">a b </span>=
      <span class="kwb">if</span> a &gt; b <span class="kwb">then</span> [] <span class="kwb">else</span> a :: aux (a+1) b  <span class="kwa">in</span>
    <span class="kwb">if</span> a &gt; b <span class="kwb">then</span> <span class="ocaml-mod">List</span>.rev (aux b a) <span class="kwb">else</span> aux a b</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">range 4 9 = [4;5;6;7;8;9]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">range 9 4 = [9;8;7;6;5;4]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q23" class="question medium">
  <div class="title">Extract a given number of randomly selected
    elements from a list.</div>
  <p>The selected items shall be returned in a list.  We use the
    <code>Random</code> module but do not initialize it
    with <code>Random.self_init</code> for reproducibility.</p>
  <button class="solution" onclick="toggleContent('q23')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">rand_select</span> <span class="ocaml-variable">list n </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">extract</span> <span class="ocaml-variable">acc n </span>= <span class="kwb">function</span>
      | [] -&gt; <span class="kwb">raise</span> Not_found
      | h :: t -&gt; <span class="kwb">if</span> n = 0 <span class="kwb">then</span> (h, acc @ t) <span class="kwb">else</span> extract (h::acc) (n-1) t
    <span class="kwa">in</span>
    <span class="kwa">let</span> <span class="ocaml-function">extract_rand</span> <span class="ocaml-variable">list len </span>=
      extract [] (<span class="ocaml-mod">Random</span>.int len) list
    <span class="kwa">in</span>
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">n acc list len </span>=
      <span class="kwb">if</span> n = 0 <span class="kwb">then</span> acc <span class="kwb">else</span>
        let picked, rest = extract_rand list len <span class="kwa">in</span>
        aux (n-1) (picked :: acc) rest (len-1)
    <span class="kwa">in</span>
    <span class="kwa">let </span><span class="ocaml-variable">len</span> = <span class="ocaml-mod">List</span>.length list <span class="kwa">in</span>
    aux (min n len) [] list len</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val rand_select : 'a list -&gt; int -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">rand_select [`a;`b;`c;`d;`e;`f;`g;`h] 3</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : [&gt; `a | `b | `c | `d | `e | `f | `g | `h ] list = [`g; `d; `a]
</span></pre>
</div>

<div id="q24" class="question easy">
  <div class="title">Lotto: Draw N different random numbers from the
    set 1..M.</div>
  <p>The selected numbers shall be returned in a list.</p>
  <button class="solution" onclick="toggleContent('q24')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* [range] and [rand_select] defined <span class="kwa">in</span> problems above *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">lotto_select</span> <span class="ocaml-variable">n m </span>= rand_select (range 1 m) n</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val lotto_select : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">lotto_select 6 49</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int list = [10; 20; 44; 22; 41; 2]
</span></pre>
</div>

<div id="q25" class="question easy">
  <div class="title">Generate a random permutation of the elements
    of a list.</div>
  <button class="solution" onclick="toggleContent('q25')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">permutation</span> <span class="ocaml-variable">list </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">extract</span> <span class="ocaml-variable">acc n </span>= <span class="kwb">function</span>
      | [] -&gt; <span class="kwb">raise</span> Not_found
      | h :: t -&gt; <span class="kwb">if</span> n = 0 <span class="kwb">then</span> (h, acc @ t) <span class="kwb">else</span> extract (h::acc) (n-1) t
    <span class="kwa">in</span>
    <span class="kwa">let</span> <span class="ocaml-function">extract_rand</span> <span class="ocaml-variable">list len </span>=
      extract [] (<span class="ocaml-mod">Random</span>.int len) list
    <span class="kwa">in</span>
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">acc list len </span>=
      <span class="kwb">if</span> len = 0 <span class="kwb">then</span> acc <span class="kwb">else</span>
        let picked, rest = extract_rand list len <span class="kwa">in</span>
        aux (picked :: acc) rest (len-1)
    <span class="kwa">in</span>
    aux [] list (<span class="ocaml-mod">List</span>.length list)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val permutation : 'a list -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">permutation ['a';'b';'c';'d';'e';'f']</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : char list = ['a'; 'e'; 'f'; 'b'; 'd'; 'c']
</span></pre>
</div>

<div id="q26" class="question medium">
  <div class="title">Generate the combinations of K distinct objects
    chosen from the N elements of a list</div>
  <p>In how many ways can a committee of 3 be chosen from a group of
    12 people? We all know that there are C(12,3) = 220 possibilities
    (C(N,K) denotes the well-known binomial coefficients). For pure
    mathematicians, this result may be great. But we want to really
    generate all the possibilities in a list.
  </p>
  <button class="solution" onclick="toggleContent('q26')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">extract</span> <span class="ocaml-variable">k list </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">k acc emit </span>= <span class="kwb">function</span>
      | [] -&gt; acc
      | h :: t -&gt;
        <span class="kwb">if</span> k = 1 <span class="kwb">then</span> aux k (emit [h] acc) emit t <span class="kwb">else</span>
          <span class="kwa">let</span> <span class="ocaml-function">new_emit</span> <span class="ocaml-variable">x </span>= emit (h :: x) <span class="kwa">in</span>
          aux k (aux (k-1) acc new_emit t) emit t
    <span class="kwa">in</span>
    <span class="kwa">let</span> <span class="ocaml-function">emit</span> <span class="ocaml-variable">x acc </span>= x :: acc <span class="kwa">in</span>
    aux k [] emit list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val extract : int -&gt; 'a list -&gt; 'a list list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">extract 2 [`a;`b;`c;`d]
  = [[`c;`d]; [`b;`d]; [`b;`c]; [`a;`d]; [`a;`c]; [`a;`b]]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q27" class="question medium">
  <div class="title">Group the elements of a set into disjoint
    subsets.</div>
  <p>a) In how many ways can a group of 9 people work in 3 disjoint
    subgroups of 2, 3 and 4 persons? Write a function that generates
    all the possibilities and returns them in a list.</p>
  <p>b) Generalize the above function in a way that we can specify
    a list of group sizes and the function will return a list of
    groups.</p>
  <button class="solution" onclick="toggleContent('q27')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* This implementation is less streamlined than the one-extraction
     version, because more work is <span class="kwb">done</span> on the lists after each transform
     <span class="kwb">to</span> prepend the actual items. The <span class="kwa">end</span> result is cleaner <span class="kwa">in</span> terms <span class="kwb">of</span>
     code, though. *)</span>

  <span class="kwa">let</span> <span class="ocaml-function">group</span> <span class="ocaml-variable">list sizes </span>=
    <span class="kwa">let </span><span class="ocaml-variable">initial</span> = <span class="ocaml-mod">List</span>.map (<span class="kwb">fun</span> size -&gt; size, []) sizes <span class="kwa">in</span>
    <span class="ocaml-comment">(* The core <span class="kwb">of</span> the function. Prepend accepts a list <span class="kwb">of</span> groups, each <span class="kwb">with</span>
       the number <span class="kwb">of</span> items that should be added, and prepends the item <span class="kwb">to</span> every
       group that can support it, thus turning [1,a ; 2,b ; 0,c] into
       [ [0,x::a ; 2,b ; 0,c ] ; [1,a ; 1,x::b ; 0,c] ; [ 1,a ; 2,b ; 0,c ]]

       Again, <span class="kwa">in</span> the prolog language (<span class="kwb">for</span> which these questions are
       originally intended), this function is a whole lot simpler.  *)</span>
    <span class="kwa">let</span> <span class="ocaml-function">prepend</span> <span class="ocaml-variable">p list </span>=
      <span class="kwa">let</span> <span class="ocaml-function">emit</span> <span class="ocaml-variable">l acc </span>= l :: acc <span class="kwa">in</span>
      <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">emit acc </span>= <span class="kwb">function</span>
        | [] -&gt; emit [] acc
        | (n,l) <span class="kwb">as</span> h :: t -&gt;
           <span class="kwa">let </span><span class="ocaml-variable">acc</span> = <span class="kwb">if</span> n &gt; 0 <span class="kwb">then</span> emit ((n-1, p::l) :: t) acc <span class="kwb">else</span> acc <span class="kwa">in</span>
           aux (<span class="kwb">fun</span> l acc -&gt; emit (h :: l) acc) acc t
      <span class="kwa">in</span>
      aux emit [] list
    <span class="kwa">in</span>
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> = <span class="kwb">function</span>
      | [] -&gt; [ initial ]
      | h :: t -&gt; <span class="ocaml-mod">List</span>.concat (<span class="ocaml-mod">List</span>.map (prepend h) (aux t))
    <span class="kwa">in</span>
    <span class="kwa">let </span><span class="ocaml-variable">all</span> = aux list <span class="kwa">in</span>
    <span class="ocaml-comment">(* Don't forget <span class="kwb">to</span> eliminate all group sets that have non-full groups *)</span>
    <span class="kwa">let </span><span class="ocaml-variable">complete</span> = <span class="ocaml-mod">List</span>.filter (<span class="ocaml-mod">List</span>.for_all (<span class="kwb">fun</span> (x,_) -&gt; x = 0)) all <span class="kwa">in</span>
    <span class="ocaml-mod">List</span>.map (<span class="ocaml-mod">List</span>.map snd) complete</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val group : 'a list -&gt; int list -&gt; 'a list list list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">group [`a;`b;`c;`d] [2;1]
  = [[[`a; `b]; [`c]]; [[`a; `c]; [`b]]; [[`b; `c]; [`a]]; [[`a; `b]; [`d]];
     [[`a; `c]; [`d]]; [[`b; `c]; [`d]]; [[`a; `d]; [`b]]; [[`b; `d]; [`a]];
     [[`a; `d]; [`c]]; [[`b; `d]; [`c]]; [[`c; `d]; [`a]]; [[`c; `d]; [`b]]]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q28" class="question medium"><a name="sort-list-sub"></a>
  <div class="title">Sorting a list of lists
    according to length of sublists</div>
  <p>a) We suppose that a list contains elements that are lists
    themselves. The objective is to sort the elements of this list
    according to their length. E.g. short lists first, longer lists
    later, or vice versa.</p>
  <p>b) Again, we suppose that a list contains elements that are
    lists themselves. But this time the objective is to sort the
    elements of this list according to their <strong>length
    frequency</strong>; i.e., in the default, where sorting is done
    ascendingly, lists with rare lengths are placed first, others with
    a more frequent length come later.</p>
  <button class="solution" onclick="toggleContent('q28')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* We might not be allowed <span class="kwb">to</span> use built-<span class="kwa">in</span> <span class="ocaml-mod">List</span>.sort, so here's an
     eight-line implementation <span class="kwb">of</span> insertion sort - O(n&sup2;) time complexity. *)</span>
  <span class="kwa">let rec</span> <span class="ocaml-function">insert</span> <span class="ocaml-variable">cmp e </span>= <span class="kwb">function</span>
    | [] -&gt; [e]
    | h :: t <span class="kwb">as</span> l -&gt; <span class="kwb">if</span> cmp e h &lt;= 0 <span class="kwb">then</span> e :: l <span class="kwb">else</span> h :: insert cmp e t

  <span class="kwa">let rec</span> <span class="ocaml-function">sort</span> <span class="ocaml-variable">cmp </span>= <span class="kwb">function</span>
    | [] -&gt; []
    | h :: t -&gt; insert cmp h (sort cmp t)

  <span class="ocaml-comment">(* Sorting according <span class="kwb">to</span> length : prepend length, sort, remove length *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">length_sort</span> <span class="ocaml-variable">lists </span>=
    <span class="kwa">let </span><span class="ocaml-variable">lists</span> = <span class="ocaml-mod">List</span>.map (<span class="kwb">fun</span> list -&gt; <span class="ocaml-mod">List</span>.length list, list) lists <span class="kwa">in</span>
    <span class="kwa">let </span><span class="ocaml-variable">lists</span> = sort (<span class="kwb">fun</span> a b -&gt; compare (fst a) (fst b)) lists <span class="kwa">in</span>
    <span class="ocaml-mod">List</span>.map snd lists</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val insert : ('a -&gt; 'a -&gt; int) -&gt; 'a -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
val length_sort : 'a list list -&gt; 'a list list = &lt;fun&gt;
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* Sorting according <span class="kwb">to</span> length frequency : prepend frequency, sort,
     remove frequency. Frequencies are extracted by sorting lengths
     and applying RLE <span class="kwb">to</span> count occurences <span class="kwb">of</span> each length (see problem
     &quot;Run-length encoding <span class="kwb">of</span> a list.&quot;) *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">rle</span> <span class="ocaml-variable">list </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">count acc </span>= <span class="kwb">function</span>
      | [] -&gt; [] <span class="ocaml-comment">(* Can only be reached <span class="kwb">if</span> original list is empty *)</span>
      | [x] -&gt; (x, count + 1) :: acc
      | a :: (b :: _ <span class="kwb">as</span> t) -&gt;
         <span class="kwb">if</span> a = b <span class="kwb">then</span> aux (count + 1) acc t
         <span class="kwb">else</span> aux 0 ((a, count + 1) :: acc) t <span class="kwa">in</span>
    aux 0 [] list

  <span class="kwa">let</span> <span class="ocaml-function">frequency_sort</span> <span class="ocaml-variable">lists </span>=
    <span class="kwa">let </span><span class="ocaml-variable">lengths</span> = <span class="ocaml-mod">List</span>.map <span class="ocaml-mod">List</span>.length lists <span class="kwa">in</span>
    <span class="kwa">let </span><span class="ocaml-variable">freq</span> = rle (sort compare lengths) <span class="kwa">in</span>
    <span class="kwa">let </span><span class="ocaml-variable">by_freq</span> =
      <span class="ocaml-mod">List</span>.map (<span class="kwb">fun</span> list -&gt; <span class="ocaml-mod">List</span>.assoc (<span class="ocaml-mod">List</span>.length list) freq , list) lists <span class="kwa">in</span>
    <span class="kwa">let </span><span class="ocaml-variable">sorted</span> = sort (<span class="kwb">fun</span> a b -&gt; compare (fst a) (fst b)) by_freq <span class="kwa">in</span>
    <span class="ocaml-mod">List</span>.map snd sorted</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val rle : 'a list -&gt; ('a * int) list = &lt;fun&gt;
val frequency_sort : 'a list list -&gt; 'a list list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">length_sort [ [`a;`b;`c]; [`d;`e]; [`f;`g;`h]; [`d;`e];
                [`i;`j;`k;`l]; [`m;`n]; [`o] ]
  = [[`o]; [`d; `e]; [`d; `e]; [`m; `n]; [`a; `b; `c]; [`f; `g; `h];
     [`i; `j; `k; `l]]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">frequency_sort [ [`a;`b;`c]; [`d;`e]; [`f;`g;`h]; [`d;`e];
                   [`i;`j;`k;`l]; [`m;`n]; [`o] ]
  = [[`i; `j; `k; `l]; [`o]; [`a; `b; `c]; [`f; `g; `h]; [`d; `e]; [`d; `e];
     [`m; `n]]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>

</div>


<h2><a name="arithmetic"></a>Arithmetic</h2>

<div id="q31" class="question medium">
  <div class="title">Determine whether a given integer number is prime.</div>
  <button class="solution" onclick="toggleContent('q31')">Solution</button>

  <div class="solution">
    <p>Recall that <code>d</code> divides <code>n</code> iff <code>n mod d =
	0</code>.  This is a naive solution.  See
      the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a> for a more clever one.</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">is_prime</span> <span class="ocaml-variable">n </span>=
    <span class="kwa">let </span><span class="ocaml-variable">n</span> = abs n <span class="kwa">in</span>
    <span class="kwa">let rec</span> <span class="ocaml-function">is_not_divisor</span> <span class="ocaml-variable">d </span>=
      d * d &gt; n || (n mod d &lt;&gt; 0 &amp;&amp; is_not_divisor (d+1)) <span class="kwa">in</span>
    n &lt;&gt; 1 &amp;&amp; is_not_divisor 2</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val is_prime : int -&gt; bool = &lt;fun&gt;
</span></pre>
  </div> 
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">not(is_prime 1)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">is_prime 7</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">not (is_prime 12)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q32" class="question medium">
  <div class="title">Determine the greatest common divisor of two
    positive integer numbers.</div>
  <p>Use Euclid's algorithm.</p>
  <button class="solution" onclick="toggleContent('q32')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">gcd</span> <span class="ocaml-variable">a b </span>=
    <span class="kwb">if</span> b = 0 <span class="kwb">then</span> a <span class="kwb">else</span> gcd b (a mod b)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val gcd : int -&gt; int -&gt; int = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">gcd 13 27 = 1</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">gcd 20536 7826 = 2</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q33" class="question easy">
  <div class="title">Determine whether two positive integer numbers
    are coprime.</div>
  <p>Two numbers are coprime if their greatest common divisor equals
    1.</p>
  <button class="solution" onclick="toggleContent('q33')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* [gcd] is defined <span class="kwa">in</span> the previous question *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">coprime</span> <span class="ocaml-variable">a b </span>= gcd a b = 1</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val coprime : int -&gt; int -&gt; bool = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">coprime 13 27</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">not (coprime 20536 7826)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q34" class="question medium"><a name="totient"></a>
  <div class="title">Calculate Euler's totient function
    phi(m).</div>
  <p>Euler's so-called totient function φ(m) is defined as the number
    of positive integers r (1 &le; r &lt; m) that are coprime to
    m.  We let φ(1) = 1.</p>
  <p>Find out what the value of phi(m) is if m is a prime
    number. Euler's totient function plays an important role in one of
    the most widely used public key cryptography methods (RSA). In this
    exercise you should use the most primitive method to calculate this
    function (there are smarter ways that we shall discuss later).
  </p>
  <button class="solution" onclick="toggleContent('q34')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* [coprime] is defined <span class="kwa">in</span> the previous question *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">phi</span> <span class="ocaml-variable">n </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">count_coprime</span> <span class="ocaml-variable">acc d </span>=
      <span class="kwb">if</span> d &lt; n <span class="kwb">then</span>
        count_coprime (<span class="kwb">if</span> coprime n d <span class="kwb">then</span> acc + 1 <span class="kwb">else</span> acc) (d + 1)
      <span class="kwb">else</span> acc
    <span class="kwa">in</span>
    <span class="kwb">if</span> n = 1 <span class="kwb">then</span> 1 <span class="kwb">else</span> count_coprime 0 1</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val phi : int -&gt; int = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">phi 10 = 4</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">phi 13 = 12</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q35" class="question medium">
  <div class="title"> Determine the prime factors of a given positive
    integer.</div>
  <p>Construct a flat list containing the prime factors in ascending
    order.</p>
  <button class="solution" onclick="toggleContent('q35')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* Recall that d divides n iff [n mod d = 0] *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">factors</span> <span class="ocaml-variable">n </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">d n </span>=
      <span class="kwb">if</span> n = 1 <span class="kwb">then</span> [] <span class="kwb">else</span>
        <span class="kwb">if</span> n mod d = 0 <span class="kwb">then</span> d :: aux d (n / d) <span class="kwb">else</span> aux (d+1) n
    <span class="kwa">in</span>
    aux 2 n</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val factors : int -&gt; int list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">factors 315 = [3;3;5;7]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q36" class="question medium">
  <div class="title">Determine the prime factors of a given positive
    integer (2).</div>
  <p>Construct a list containing the prime factors and their
    multiplicity.  <em>Hint:</em> The problem is similar to problem
    <a href="#run-length-direct">Run-length encoding of a list
    (direct solution)</a>.</p>
  <button class="solution" onclick="toggleContent('q36')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">factors</span> <span class="ocaml-variable">n </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">d n </span>=
      <span class="kwb">if</span> n = 1 <span class="kwb">then</span> [] <span class="kwb">else</span>
        <span class="kwb">if</span> n mod d = 0 <span class="kwb">then</span>
          <span class="kwb">match</span> aux d (n / d) <span class="kwb">with</span>
          | (h,n) :: t when h = d -&gt; (h,n+1) :: t
          | l -&gt; (d,1) :: l
        <span class="kwb">else</span> aux (d+1) n
    <span class="kwa">in</span>
    aux 2 n</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val factors : int -&gt; (int * int) list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">factors 315 = [3,2 ; 5,1 ; 7,1]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>


<div id="q37" class="question medium"><a name="totient-improved"></a>
  <div class="title">Calculate Euler's totient function phi(m)
    (improved).</div>
  <p>See problem “<a href="#totient">Calculate Euler's totient
  function phi(m)</a>” for the definition of Euler's totient function.
  If the list of the prime factors of a number m is known in the form
  of the previous problem then the function phi(m) can be efficiently
  calculated as follows: Let <code>[(p1, m1); (p2, m2);
  (p3, m3); ...]</code> be the list of prime factors (and their
  multiplicities) of a given number m. Then φ(m) can be calculated
  with the following formula:
  </p>
  <center>
    φ(m) = (p1 - 1) × p1<sup>m1 - 1</sup>
    × (p2 - 1) × p2<sup>m2 - 1</sup>
    × (p3 - 1) × p3<sup>m3 - 1</sup> × ...
  </center>
  <button class="solution" onclick="toggleContent('q37')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* Naive power function. *)</span>
  <span class="kwa">let rec</span> <span class="ocaml-function">pow</span> <span class="ocaml-variable">n p </span>= <span class="kwb">if</span> p &lt; 1 <span class="kwb">then</span> 1 <span class="kwb">else</span> n * pow n (p-1)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val pow : int -&gt; int -&gt; int = &lt;fun&gt;
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* [factors] is defined <span class="kwa">in</span> the previous question. *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">phi_improved</span> <span class="ocaml-variable">n </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">acc </span>= <span class="kwb">function</span>
      | [] -&gt; acc
      | (p,m) :: t -&gt; aux ((p - 1) * pow p (m - 1) * acc) t <span class="kwa">in</span>
    aux 1 (factors n)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val phi_improved : int -&gt; int = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">phi_improved 10 = 4</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">phi_improved 13 = 12</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q38" class="question easy"><a name="timeit"></a>
  <div class="title">Compare the two methods of
    calculating Euler's totient function.</div>
  <p>Use the solutions of problems “<a href="#totient">Calculate
      Euler's totient function phi(m)</a>” and
    “<a href="#totient-improved">Calculate Euler's totient function
      phi(m) (improved)</a>” to compare the algorithms. Take the number of
    logical inferences as a measure for efficiency. Try to calculate
    φ(10090) as an example.</p>
  <button class="solution" onclick="toggleContent('q38')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* Naive [timeit] function.  It requires the [Unix] module <span class="kwb">to</span> be loaded. *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">timeit</span> <span class="ocaml-variable">f a </span>=
    <span class="kwa">let </span><span class="ocaml-variable">t0</span> = <span class="ocaml-mod">Unix</span>.gettimeofday() <span class="kwa">in</span>
    ignore(f a);
    <span class="kwa">let </span><span class="ocaml-variable">t1</span> = <span class="ocaml-mod">Unix</span>.gettimeofday() <span class="kwa">in</span>
    t1 -. t0</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val timeit : ('a -&gt; 'b) -&gt; 'a -&gt; float = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">timeit phi 10090</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : float = 0.00304293632507324219
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">timeit phi_improved 10090</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : float = 2.98023223876953125e-05
</span></pre>
</div>

<div id="q39" class="question easy">
  <div class="title">A list of prime numbers.</div>
  <p>Given a range of integers by its lower and upper limit, construct
    a list of all prime numbers in that range.</p>
  <button class="solution" onclick="toggleContent('q39')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">is_prime</span> <span class="ocaml-variable">n </span>=
    <span class="kwa">let </span><span class="ocaml-variable">n</span> = max n (-n) <span class="kwa">in</span>
    <span class="kwa">let rec</span> <span class="ocaml-function">is_not_divisor</span> <span class="ocaml-variable">d </span>=
      d * d &gt; n || (n mod d &lt;&gt; 0 &amp;&amp; is_not_divisor (d+1)) <span class="kwa">in</span>
    is_not_divisor 2

  <span class="kwa">let rec</span> <span class="ocaml-function">all_primes</span> <span class="ocaml-variable">a b </span>=
    <span class="kwb">if</span> a &gt; b <span class="kwb">then</span> [] <span class="kwb">else</span>
      <span class="kwa">let </span><span class="ocaml-variable">rest</span> = all_primes (a + 1) b <span class="kwa">in</span>
      <span class="kwb">if</span> is_prime a <span class="kwb">then</span> a :: rest <span class="kwb">else</span> rest</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val is_prime : int -&gt; bool = &lt;fun&gt;
val all_primes : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.length (all_primes 2 7920) = 1000</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q40" class="question medium">
  <div class="title">Goldbach's conjecture.</div>
  <p>Goldbach's conjecture says that every positive even number
    greater than 2 is the sum of two prime numbers. Example: 28 =
    5 + 23. It is one of the most famous facts in number theory that has
    not been proved to be correct in the general case. It has been
    <em>numerically confirmed</em> up to very large numbers.  Write a
    function to find the two prime numbers that sum up to a given
    even integer.
  </p>
  <button class="solution" onclick="toggleContent('q40')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* [is_prime] is defined <span class="kwa">in</span> the previous solution *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">goldbach</span> <span class="ocaml-variable">n </span>=
    <span class="kwa">let rec</span> <span class="ocaml-function">aux</span> <span class="ocaml-variable">d </span>=
      <span class="kwb">if</span> is_prime d &amp;&amp; is_prime (n - d) <span class="kwb">then</span> (d, n-d)
      <span class="kwb">else</span> aux (d+1) <span class="kwa">in</span>
    aux 2</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val goldbach : int -&gt; int * int = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">goldbach 28 = (5,23)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>


<div id="q41" class="question medium">
  <div class="title">A list of Goldbach compositions.</div>
  <p>Given a range of integers by its lower and upper limit, print a
    list of all even numbers and their Goldbach composition.</p>
  <p>In most cases, if an even number is written as the sum of two
    prime numbers, one of them is very small. Very rarely, the primes
    are both bigger than say 50. Try to find out how many such cases
    there are in the range 2..3000.
  </p>
  <button class="solution" onclick="toggleContent('q41')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* [goldbach] is defined <span class="kwa">in</span> the previous question. *)</span>
  <span class="kwa">let rec</span> <span class="ocaml-function">goldbach_list</span> <span class="ocaml-variable">a b </span>=
    <span class="kwb">if</span> a &gt; b <span class="kwb">then</span> [] <span class="kwb">else</span>
      <span class="kwb">if</span> a mod 2 = 1 <span class="kwb">then</span> goldbach_list (a+1) b
      <span class="kwb">else</span> (a, goldbach a) :: goldbach_list (a+2) b

  <span class="kwa">let</span> <span class="ocaml-function">goldbach_limit</span> <span class="ocaml-variable">a b lim </span>=
    <span class="ocaml-mod">List</span>.filter (<span class="kwb">fun</span> (_,(a,b)) -&gt; a &gt; lim &amp;&amp; b &gt; lim) (goldbach_list a b)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val goldbach_list : int -&gt; int -&gt; (int * (int * int)) list = &lt;fun&gt;
val goldbach_limit : int -&gt; int -&gt; int -&gt; (int * (int * int)) list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">goldbach_list 9 20
  = [(10, (3, 7)); (12, (5, 7)); (14, (3, 11)); (16, (3, 13)); (18, (5, 13));
     (20, (3, 17))]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">goldbach_limit 1 2000 50
  = [(992, (73, 919)); (1382, (61, 1321)); (1856, (67, 1789));
     (1928, (61, 1867))]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>


<h2><a name="logic"></a>Logic and Codes</h2>

Let us define a small “language” for boolean expressions containing
variables:
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">type</span> <span class="ocaml-mod">bool_expr</span> =
    | Var <span class="kwb">of</span> string
    | Not <span class="kwb">of</span> bool_expr
    | And <span class="kwb">of</span> bool_expr * bool_expr
    | Or <span class="kwb">of</span> bool_expr * bool_expr</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>type bool_expr =
    Var of string
  | Not of bool_expr
  | And of bool_expr * bool_expr
  | Or of bool_expr * bool_expr
</span></pre>
A logical expression in two variables can then be written in prefix
notation, as in the following example:
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">And(Or(Var &quot;a&quot;, Var &quot;b&quot;), And(Var &quot;a&quot;, Var &quot;b&quot;))</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool_expr = And (Or (Var &quot;a&quot;, Var &quot;b&quot;), And (Var &quot;a&quot;, Var &quot;b&quot;))
</span></pre>

<div id="q46" class="question medium">
  <div class="title">Truth tables for logical expressions (2
    variables).</div>
  <p>Define a function, <code>table2</code> which returns the truth
    table of a given logical expression in two variables (specified as
    arguments).  The return value must be a
    list of triples containing <code>(value_of_a, balue_of_b,
    value_of_expr)</code>.</p>
  <button class="solution" onclick="toggleContent('q46')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">eval2</span> <span class="ocaml-variable">a val_a b val_b </span>= <span class="kwb">function</span>
    | Var x -&gt; <span class="kwb">if</span> x = a <span class="kwb">then</span> val_a
               <span class="kwb">else</span> <span class="kwb">if</span> x = b <span class="kwb">then</span> val_b
               <span class="kwb">else</span> <span class="kwb">failwith</span> &quot;The expression contains an invalid variable&quot;
    | Not e -&gt; not(eval2 a val_a b val_b e)
    | And(e1, e2) -&gt; eval2 a val_a b val_b e1 &amp;&amp; eval2 a val_a b val_b e2
    | Or(e1, e2) -&gt; eval2 a val_a b val_b e1 || eval2 a val_a b val_b e2
  <span class="kwa">let</span> <span class="ocaml-function">table2</span> <span class="ocaml-variable">a b expr </span>=
    [(true,  true,  eval2 a true  b true  expr);
     (true,  false, eval2 a true  b false expr);
     (false, true,  eval2 a false b true  expr);
     (false, false, eval2 a false b false expr) ]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val eval2 : string -&gt; bool -&gt; string -&gt; bool -&gt; bool_expr -&gt; bool = &lt;fun&gt;
val table2 : string -&gt; string -&gt; bool_expr -&gt; (bool * bool * bool) list =
  &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">table2 &quot;a&quot; &quot;b&quot; (And(Var &quot;a&quot;, Or(Var &quot;a&quot;, Var &quot;b&quot;)))
  = [(true, true, true);
     (true, false, true);
     (false, true, false);
     (false, false, false) ]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q48" class="question medium">
  <div class="title">Truth tables for logical expressions.</div>
  <p>Generalize the previous problem in such a way that the logical
    expression may contain any number of logical variables.  Define
      <code>table</code> in a way that <code>table variables
	expr</code> returns the truth table for the
      expression <code>expr</code>, which contains the logical
      variables enumerated in <code>variables</code>.</p>
  <button class="solution" onclick="toggleContent('q48')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* [val_vars] is an associative list containing the truth value <span class="kwb">of</span>
     each variable.  For efficiency, a Map or a Hashtlb should be preferred. *)</span>
  <span class="kwa">let rec</span> <span class="ocaml-function">eval</span> <span class="ocaml-variable">val_vars </span>= <span class="kwb">function</span>
    | Var x -&gt; <span class="ocaml-mod">List</span>.assoc x val_vars
    | Not e -&gt; not(eval val_vars e)
    | And(e1, e2) -&gt; eval val_vars e1 &amp;&amp; eval val_vars e2
    | Or(e1, e2) -&gt; eval val_vars e1 || eval val_vars e2

  <span class="ocaml-comment">(* Again, this is an easy and short implementation rather than an
     efficient one. *)</span>
  <span class="kwa">let rec</span> <span class="ocaml-function">table_make</span> <span class="ocaml-variable">val_vars vars expr </span>=
    <span class="kwb">match</span> vars <span class="kwb">with</span>
    | [] -&gt; [(<span class="ocaml-mod">List</span>.rev val_vars, eval val_vars expr)]
    | v :: tl -&gt;
       table_make ((v, true) :: val_vars) tl expr
       @ table_make ((v, false) :: val_vars) tl expr

  <span class="kwa">let</span> <span class="ocaml-function">table</span> <span class="ocaml-variable">vars expr </span>= table_make [] vars expr</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val eval : (string * bool) list -&gt; bool_expr -&gt; bool = &lt;fun&gt;
val table_make :
  (string * bool) list -&gt;
  string list -&gt; bool_expr -&gt; ((string * bool) list * bool) list = &lt;fun&gt;
val table : string list -&gt; bool_expr -&gt; ((string * bool) list * bool) list =
  &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">table [&quot;a&quot;; &quot;b&quot;] (And(Var &quot;a&quot;, Or(Var &quot;a&quot;, Var &quot;b&quot;)))
  = [[&quot;a&quot;, true; &quot;b&quot;, true], true;
     [&quot;a&quot;, true; &quot;b&quot;, false], true;
     [&quot;a&quot;, false; &quot;b&quot;, true], false;
     [&quot;a&quot;, false; &quot;b&quot;, false], false ]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">a</span> = Var &quot;a&quot; <span class="kwa">and </span><span class="ocaml-variable">b</span> = Var &quot;b&quot; <span class="kwa">and </span><span class="ocaml-variable">c</span> = Var &quot;c&quot; <span class="kwa">in</span>
  table [&quot;a&quot;; &quot;b&quot;; &quot;c&quot;] (Or(And(a, Or(b,c)), Or(And(a,b), And(a,c))))</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : ((string * bool) list * bool) list =
[([(&quot;a&quot;, true); (&quot;b&quot;, true); (&quot;c&quot;, true)], true);
 ([(&quot;a&quot;, true); (&quot;b&quot;, ...); ...], ...); ...]
</span></pre>
</div>

<div id="q49" class="question medium">
  <div class="title">Gray code.</div>
  <p>An n-bit Gray code is a sequence of n-bit strings constructed
    according to certain rules. For example,</p>
<pre>
n = 1: C(1) = ['0','1'].
n = 2: C(2) = ['00','01','11','10'].
n = 3: C(3) = ['000','001','011','010',´110´,´111´,´101´,´100´].
</pre>
  <p>Find out the construction rules and write a function with the
    following specification: <code>gray n</code> returns
    the <code>n</code>-bit Gray code.</p>
  <button class="solution" onclick="toggleContent('q49')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">prepend</span> <span class="ocaml-variable">c s </span>=
  <span class="ocaml-comment">(* Prepend the char [c] <span class="kwb">to</span> the string [s]. *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">s'</span> = <span class="ocaml-mod">String</span>.create (<span class="ocaml-mod">String</span>.length s + 1) <span class="kwa">in</span>
  s'.[0] &lt;- c;
  <span class="ocaml-mod">String</span>.blit s 0 s' 1 (<span class="ocaml-mod">String</span>.length s);
  s'

<span class="kwa">let rec</span> <span class="ocaml-function">gray</span> <span class="ocaml-variable">n </span>=
  <span class="kwb">if</span> n &lt;= 1 <span class="kwb">then</span> [&quot;0&quot;; &quot;1&quot;]
  <span class="kwb">else</span> <span class="kwa">let </span><span class="ocaml-variable">g</span> = gray (n - 1) <span class="kwa">in</span>
       <span class="ocaml-mod">List</span>.map (prepend '0') g @ <span class="ocaml-mod">List</span>.map (prepend '1') g</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val prepend : char -&gt; string -&gt; string = &lt;fun&gt;
val gray : int -&gt; string list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">gray 1 = [&quot;0&quot;; &quot;1&quot;]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">gray 2 = [&quot;00&quot;; &quot;01&quot;; &quot;11&quot;; &quot;10&quot;]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = false
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">gray 3 = [&quot;000&quot;; &quot;001&quot;; &quot;011&quot;; &quot;010&quot;; &quot;110&quot;; &quot;111&quot;; &quot;101&quot;; &quot;100&quot;]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = false
</span></pre>
</div>

<div id="q50" class="question hard">
  <div class="title">Huffman code.</div>
  <p>First of all, consult a good book on discrete mathematics or
    algorithms for a detailed description of Huffman codes (you can
    start with
    the <a href="http://en.wikipedia.org/wiki/Huffman_coding">Wikipedia page</a>)!</p>
  <p>We suppose a set of symbols with their frequencies, given as a
    list of <code>Fr(S,F)</code> terms. Example:
    <code>fs = [Fr(a,45); Fr(b,13); Fr(c,12); Fr(d,16); Fr(e,9);
      Fr(f,5)]</code>. Our objective is to construct a
      list <code>Hc(S,C)</code> terms, where <code>C</code> is the
      Huffman code word for the symbol <code>S</code>. In our example,
      the result could be <code>hs = [Hc(a,'0'); Hc(b,'101'); Hc(c,'100');
      Hc(d,'111'); Hc(e,'1101'); hc(f,'1100')]</code>
      [hc(a,'01'),...etc.]. The task shall be performed by the
      function <code>huffman</code> defined as follows:
    <code>huffman(fs)</code> returns the Huffman code table for the
    frequency table <code>fs</code></p>
<button class="solution" onclick="toggleContent('q50')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>


<h2><a name="bin-tree"></a>Binary Trees</h2>

<div style="float: right">&nbsp;<img src="https://sites.google.com/site/prologsite/_/rsrc/1264934442609/prolog-problems/4/p67.gif" alt="Binary tree"/>
</div>
<p><em>A binary tree is either empty or it is composed of a root element
    and two successors, which are binary trees themselves.</em></p>
<p>In OCaml, one can define a new type <code>binary_tree</code> that
  carries an arbitrary value of type <code>'a</code> at each node.

</p>
<pre style="width: 75%"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">type</span> 'a <span class="ocaml-mod">binary_tree</span> =
    | Empty
    | Node <span class="kwb">of</span> 'a * 'a binary_tree * 'a binary_tree</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>type 'a binary_tree = Empty | Node of 'a * 'a binary_tree * 'a binary_tree
</span></pre>
  <p>An example of tree carrying <code>char</code> data is:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">example_tree</span> =
    Node('a', Node('b', Node('d', Empty, Empty), Node('e', Empty, Empty)),
         Node('c', Empty, Node('f', Node('g', Empty, Empty), Empty)))</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val example_tree : char binary_tree =
  Node ('a', Node ('b', Node ('d', Empty, Empty), Node ('e', Empty, Empty)),
   Node ('c', Empty, Node ('f', Node ('g', Empty, ...), ...)))
</span></pre>
  <p>In OCaml, the strict type discipline <em>guarantees</em> that, if
  you get a value of type <code>binary_tree</code>, then it must have
  been created with the two constructors <code>Empty</code>
  and <code>Node</code>.
</p>

<div id="q55" class="question medium">
  <div class="title">Construct completely balanced binary
    trees</div>
  <p>In a completely balanced binary tree, the following property
    holds for every node: The number of nodes in its left subtree and
    the number of nodes in its right subtree are almost equal, which
    means their difference is not greater than one.</p>
  <p>Write a function <code>cbal_tree</code> to construct completely
    balanced binary trees for a given number of nodes.  The function
    should generate all solutions via backtracking.  Put the
    letter <code>'x'</code> as information into all nodes of the
    tree.</p>
  
  <button class="solution" onclick="toggleContent('q55')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* Build all trees <span class="kwb">with</span> given [left] and [right] subtrees. *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">add_trees_with</span> <span class="ocaml-variable">left right all </span>=
    <span class="kwa">let</span> <span class="ocaml-function">add_right_tree</span> <span class="ocaml-variable">all l </span>=
      <span class="ocaml-mod">List</span>.fold_left (<span class="kwb">fun</span> a r -&gt; Node('x', l, r) :: a) all right <span class="kwa">in</span>
    <span class="ocaml-mod">List</span>.fold_left add_right_tree all left
  
  <span class="kwa">let rec</span> <span class="ocaml-function">cbal_tree</span> <span class="ocaml-variable">n </span>=
    <span class="kwb">if</span> n = 0 <span class="kwb">then</span> [Empty]
    <span class="kwb">else</span> <span class="kwb">if</span> n mod 2 = 1 <span class="kwb">then</span>
      <span class="kwa">let </span><span class="ocaml-variable">t</span> = cbal_tree (n / 2) <span class="kwa">in</span>
      add_trees_with t t []
    <span class="kwb">else</span> <span class="ocaml-comment">(* n even: n-1 nodes <span class="kwb">for</span> the left &amp; right subtrees altogether. *)</span>
      <span class="kwa">let </span><span class="ocaml-variable">t1</span> = cbal_tree (n / 2 - 1) <span class="kwa">in</span>
      <span class="kwa">let </span><span class="ocaml-variable">t2</span> = cbal_tree (n / 2) <span class="kwa">in</span>
      add_trees_with t1 t2 (add_trees_with t2 t1 [])</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val add_trees_with :
  char binary_tree list -&gt;
  char binary_tree list -&gt; char binary_tree list -&gt; char binary_tree list =
  &lt;fun&gt;
val cbal_tree : int -&gt; char binary_tree list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">cbal_tree 4
  = [Node('x', Node('x', Empty, Empty),
          Node('x', Node('x', Empty, Empty), Empty));
     Node('x', Node('x', Empty, Empty),
          Node('x', Empty, Node('x', Empty, Empty)));
     Node('x', Node('x', Node('x', Empty, Empty), Empty),
          Node('x', Empty, Empty));
     Node('x', Node('x', Empty, Node('x', Empty, Empty)),
          Node('x', Empty, Empty)); ]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.length(cbal_tree 40)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int = 524288
</span></pre>
</div>

<div id="q56" class="question medium">
  <div class="title">Symmetric binary trees</div>
  <p>Let us call a binary tree symmetric if you can draw a vertical
    line through the root node and then the right subtree is the
    mirror image of the left subtree. Write a
    function <code>is_symmetric</code> to check whether a given binary
    tree is symmetric.</p>
  <p>Hint: Write a function
    <code>is_mirror</code> first to check whether one tree is the mirror
    image of another.  We are only interested in the structure, not in
    the contents of the nodes.</p>
  <button class="solution" onclick="toggleContent('q56')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">is_mirror</span> <span class="ocaml-variable">t1 t2 </span>=
    <span class="kwb">match</span> t1, t2 <span class="kwb">with</span>
    | Empty, Empty -&gt; true
    | Node(_, l1, r1), Node(_, l2, r2) -&gt;
       is_mirror l1 r2 &amp;&amp; is_mirror r1 l2
    | _ -&gt; false

  <span class="kwa">let</span> <span class="ocaml-function">is_symmetric</span> = <span class="kwb">function</span>
    | Empty -&gt; true
    | Node(_, l, r) -&gt; is_mirror l r</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val is_mirror : 'a binary_tree -&gt; 'b binary_tree -&gt; bool = &lt;fun&gt;
val is_symmetric : 'a binary_tree -&gt; bool = &lt;fun&gt;
</span></pre>
</div>

<div id="q57" class="question medium">
  <div class="title">Binary search trees (dictionaries)</div>
  <p>Construct
    a <a target="_blank" href="http://en.wikipedia.org/wiki/Binary_search_tree">binary search tree</a> from a list of integer
    numbers.</p>
  <button class="solution" onclick="toggleContent('q57')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">insert</span> <span class="ocaml-variable">tree x </span>= <span class="kwb">match</span> tree <span class="kwb">with</span>
    | Empty -&gt; Node(x, Empty, Empty)
    | Node(y, l, r) -&gt;
       <span class="kwb">if</span> x = y <span class="kwb">then</span> tree
       <span class="kwb">else</span> <span class="kwb">if</span> x &lt; y <span class="kwb">then</span> Node(y, insert l x, r)
       <span class="kwb">else</span> Node(y, l, insert r x)

  <span class="kwa">let</span> <span class="ocaml-function">construct</span> <span class="ocaml-variable">l </span>= <span class="ocaml-mod">List</span>.fold_left insert Empty l</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val insert : 'a binary_tree -&gt; 'a -&gt; 'a binary_tree = &lt;fun&gt;
val construct : 'a list -&gt; 'a binary_tree = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">construct [3;2;5;7;1]
  = Node(3, Node(2, Node(1, Empty, Empty), Empty),
         Node(5, Empty, Node(7, Empty, Empty)))</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
  <p>Then use this function to test the solution of the previous
    problem.</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">is_symmetric(construct [5;3;18;1;4;12;21])</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">not(is_symmetric(construct [3;2;5;7;4]))</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q58" class="question medium">
  <div class="title">Generate-and-test paradigm</div>
  <p>Apply the generate-and-test paradigm to construct all symmetric,
    completely balanced binary trees with a given number of nodes.</p>
  <button class="solution" onclick="toggleContent('q58')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">sym_cbal_trees</span> <span class="ocaml-variable">n </span>=
    <span class="ocaml-mod">List</span>.filter is_symmetric (cbal_tree n)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val sym_cbal_trees : int -&gt; char binary_tree list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">sym_cbal_trees 5
  = [Node('x', Node('x', Node('x', Empty, Empty), Empty),
               Node('x', Empty, Node('x', Empty, Empty)));
     Node('x', Node('x', Empty, Node('x', Empty, Empty)),
               Node('x', Node('x', Empty, Empty), Empty)) ]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
<p>
  How many such trees are there with 57 nodes? Investigate about how
  many solutions there are for a given number of nodes? What if the
  number is even?  Write an appropriate function.
</p>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.length (sym_cbal_trees 57)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int = 256
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.map (<span class="kwb">fun</span> n -&gt; n, <span class="ocaml-mod">List</span>.length(sym_cbal_trees n)) (range 10 20)
  = [(10, 0); (11, 4); (12, 0); (13, 4); (14, 0); (15, 1);
     (16, 0); (17, 8); (18, 0); (19, 16); (20, 0)]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q59" class="question medium">
  <div class="title">Construct height-balanced binary trees</div>
  <p>In a height-balanced binary tree, the following property holds
    for every node: The height of its left subtree and the height of its
    right subtree are almost equal, which means their difference is not
    greater than one.</p>
  <p>Write a function <code>hbal_tree</code> to construct
    height-balanced binary trees for a given height. The function
    should generate all solutions via backtracking. Put the
    letter <code>'x'</code> as information into all nodes of the
    tree.</p>
  <button class="solution" onclick="toggleContent('q59')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">hbal_tree</span> <span class="ocaml-variable">n </span>=
    <span class="kwb">if</span> n = 0 <span class="kwb">then</span> [Empty]
    <span class="kwb">else</span> <span class="kwb">if</span> n = 1 <span class="kwb">then</span> [Node('x', Empty, Empty)]
    <span class="kwb">else</span>
      <span class="ocaml-comment">(* [add_trees_with left right trees] is defined <span class="kwa">in</span> a question above. *)</span>
      <span class="kwa">let </span><span class="ocaml-variable">t1</span> = hbal_tree (n - 1)
      <span class="kwa">and </span><span class="ocaml-variable">t2</span> = hbal_tree (n - 2) <span class="kwa">in</span>
      add_trees_with t1 t1 (add_trees_with t1 t2 (add_trees_with t2 t1 []))</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val hbal_tree : int -&gt; char binary_tree list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">t</span> = hbal_tree 3</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val t : char binary_tree list =
  [Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
    Node ('x', Empty, Node ('x', Empty, Empty)));
   Node ('x', Node (...), ...); ...]
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">x</span> = 'x'</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val x : char = 'x'
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.mem (Node(x, Node(x, Node(x, Empty, Empty), Node(x, Empty, Empty)),
                 Node(x, Node(x, Empty, Empty), Node(x, Empty, Empty)))) t</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.mem (Node(x, Node(x, Node(x, Empty, Empty), Node(x, Empty, Empty)),
                 Node(x, Node(x, Empty, Empty), Empty))) t</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.length t = 15</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q60" class="question medium">
  <div class="title">Construct height-balanced binary trees with a
    given number of nodes</div>
  <p>Consider a height-balanced binary tree of height <code>h</code>.
    What is the maximum number of nodes it can contain?
    Clearly, <em>maxN = 2<sup><code>h</code></sup> - 1</em>. However,
    what is the minimum number <em>minN</em>? This question is more
    difficult.  Try to find a recursive statement and turn it into a
    function
    <code>minNodes</code> defined as follows:
    <code>minNodes h</code> returns the minimum number of nodes in a
    height-balanced binary tree of height <code>h</code>.</p>
  <button class="solution" onclick="toggleContent('q60')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
  <p>On the other hand, we might ask: what is the maximum height H a
    height-balanced binary tree with N nodes can have?
    <code>maxHeight n</code> returns the maximum height of a
    height-balanced binary tree with <code>n</code> nodes.
  </p>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
  <p>Now, we can attack the main problem: construct all the
    height-balanced binary trees with a given nuber of nodes.
    <code>hbal_tree_nodes n</code> returns a list of all height-balanced
    binary tree with <code>n</code> nodes.
  </p>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
  <p>Find out how many height-balanced trees exist for <code>n =
      15</code>.</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.length (hbal_tree_nodes 15)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-error">File &quot;&quot;, line 1, characters 13-28:
Error: Unbound value hbal_tree_nodes
</span></pre>
</div>

<div id="q61" class="question easy">
  <div class="title">Count the leaves of a binary tree</div>
  <p>A leaf is a node with no successors. Write a function
    <code>count_leaves</code> to count them. </p>
  <button class="solution" onclick="toggleContent('q61')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">count_leaves</span> = <span class="kwb">function</span>
    | Empty -&gt; 0
    | Node(_, Empty, Empty) -&gt; 1
    | Node(_, l, r) -&gt; count_leaves l + count_leaves r</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val count_leaves : 'a binary_tree -&gt; int = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">count_leaves Empty = 0</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">count_leaves example_tree = 3</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q61_a" class="question easy">
  <div class="title">Collect the leaves of a binary tree in a
    list</div>
  <p>A leaf is a node with no successors. Write a
    function <code>leaves</code> to collect them in a list.</p>
  <button class="solution" onclick="toggleContent('q61_a')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">leaves</span> = <span class="kwb">function</span>
    | Empty -&gt; []
    | Node(c, Empty, Empty) -&gt; [c]
    | Node(_, l, r) -&gt; leaves l @ leaves r</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val leaves : 'a binary_tree -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">leaves Empty = []</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">leaves example_tree = ['d'; 'e'; 'g']</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q62" class="question easy">
  <div class="title">Collect the internal nodes of a binary tree in
    a list</div>
  <p>An internal node of a binary tree has either one or two non-empty
    successors.  Write a function <code>internals</code> to collect them
    in a list. </p>
  <button class="solution" onclick="toggleContent('q62')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">internals</span> = <span class="kwb">function</span>
    | Empty | Node(_, Empty, Empty) -&gt; []
    | Node(c, l, r) -&gt; internals l @ (c :: internals r)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val internals : 'a binary_tree -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">internals (Node('a', Empty, Empty)) = []</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">internals example_tree = ['b'; 'a'; 'c'; 'f']</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q62_b" class="question easy">
  <div class="title">Collect the nodes at a given level in a
    list.</div>
  <p>A node of a binary tree is at level N if the path from the root to
    the node has length N-1.  The root node is at level 1.  Write a
    function <code>at_level t l</code> to collect all nodes of the
    tree <code>t</code> at  level <code>l</code> in a list. </p>
  <button class="solution" onclick="toggleContent('q62_b')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">at_level</span> <span class="ocaml-variable">t l </span>= <span class="kwb">match</span> t <span class="kwb">with</span>
    | Empty -&gt; []
    | Node(c, left, right) -&gt;
       <span class="kwb">if</span> l = 1 <span class="kwb">then</span> [c]
       <span class="kwb">else</span> at_level left (l - 1) @ at_level right (l - 1)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val at_level : 'a binary_tree -&gt; int -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">at_level example_tree 2 = ['b'; 'c']</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">at_level example_tree 2 = ['b'; 'c']</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">at_level example_tree 5 = []</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
  <p>Using <code>at_level</code> it is easy to construct a function
    <code>levelorder</code> which creates the level-order sequence of
    the nodes. However, there are more efficient ways to do that. </p>
</div>

<div id="q63" class="question medium">
  <div class="title">Construct a complete binary tree</div>
  <p>A <em>complete</em> binary tree with height H is defined as
    follows: The levels 1,2,3,...,H-1 contain the maximum number of nodes
    (i.e 2<sup>i-1</sup> at the level i, note that we start counting the levels
    from 1 at the root). In level H, which may contain less than the
    maximum possible number of nodes, all the nodes are
    "left-adjusted". This means that in a levelorder tree traversal all
    internal nodes come first, the leaves come second, and empty
    successors (the nil's which are not really nodes!) come last.</p>
  <p>Particularly, complete binary trees are used as data structures (or
    addressing schemes) for heaps.</p>
  <p>We can assign an address number to each node in a complete binary
    tree by enumerating the nodes in levelorder, starting at the root with
    number 1. In doing so, we realize that for every node X with address A
    the following property holds: The address of X's left and right
    successors are 2*A and 2*A+1, respectively, supposed the successors do
    exist. This fact can be used to elegantly construct a complete binary
    tree structure.  Write a function <code>is_complete_binary_tree</code>
    with the following specification:
    <code>is_complete_binary_tree n t</code> returns <code>true</code>
    iff <code>t</code> is a complete binary tree with <code>n</code>
    nodes.</p>
<button class="solution" onclick="toggleContent('q63')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q64" class="question medium">
  <div class="title">Layout a binary tree (1)</div>
  <p>As a preparation for drawing the tree, a layout algorithm is
    required to determine the position of each node in a rectangular
    grid. Several layout methods are conceivable, one of them is shown in
    the illustration below.</p>
  <center>
    <img src="https://sites.google.com/site/prologsite/_/rsrc/1264933989828/prolog-problems/4/p64.gif" alt="grid"/>
  </center>
  <p>In this layout strategy, the position of a node v is obtained by
    the following two rules:</p>
  <ul>
    <li><em>x(v)</em> is equal to the position of the node v in the
      <em>inorder</em> sequence;</li>
    <li><em>y(v)</em> is equal to the depth of the node <em>v</em> in
      the tree.</li>
  </ul>
  <p>In order to store the position of the nodes, we redefine the OCaml
    type representing a node (and its successors) as follows: </p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">type</span> 'a <span class="ocaml-mod">pos_binary_tree</span> =
    | E <span class="ocaml-comment">(* represents the empty tree *)</span>
    | N <span class="kwb">of</span> 'a * int * int * 'a pos_binary_tree * 'a pos_binary_tree</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>type 'a pos_binary_tree =
    E
  | N of 'a * int * int * 'a pos_binary_tree * 'a pos_binary_tree
</span></pre>
  <p><code>N(w,x,y,l,r)</code> represents a (non-empty) binary tree with
    root <code>w</code> "positioned" at <code>(x,y)</code>, and
    subtrees <code>l</code> and <code>r</code>.  Write a function
    <code>layout_binary_tree</code> with the following
    specification: <code>layout_binary_tree t</code> returns the
    "positioned" binary tree obtained from the binary tree <code>t</code>.
  </p>
  <button class="solution" onclick="toggleContent('q64')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q65" class="question medium">
  <div class="title">Layout a binary tree (2)</div>
  <center>
    <img src="https://sites.google.com/site/prologsite/_/rsrc/1264934255598/prolog-problems/4/p65.gif"/>
  </center>
  <p>An alternative layout method is depicted in the above illustration.
    Find out the rules and write the corresponding OCaml function.</p>
  <p>Hint: On a given level, the horizontal distance between neighboring
    nodes is constant.</p>
  <button class="solution" onclick="toggleContent('q65')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q66" class="question hard">
  <div class="title">Layout a binary tree (3)</div>
  <p>Yet another layout strategy is shown in the above illustration. The
    method yields a very compact layout while maintaining a certain
    symmetry in every node. Find out the rules and write the corresponding
    Prolog predicate.</p>
  <p>Hint: Consider the horizontal distance between a node and its
    successor nodes. How tight can you pack together two subtrees to
    construct the combined binary tree?  This is a difficult
    problem.  Don't give up too early!</p>
  <button class="solution" onclick="toggleContent('q66')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
  <p>Which layout do you like most?</p>
</div>

<div id="q67" class="question medium"><a name="tree-string"></a>
  <div class="title">A string representation
    of binary trees</div>
  <img src="https://sites.google.com/site/prologsite/_/rsrc/1264934442609/prolog-problems/4/p67.gif" style="float:right" alt="binary tree"/>
  <p>Somebody represents binary trees as strings of the following type
    (see example):
    <code>"a(b(d,e),c(,f(g,)))"</code>.</p>
  <ul>
    <li>Write an OCaml function which generates this string
      representation, if the tree is given as usual
      (as <code>Empty</code> or <code>Node(x,l,r)</code> term).  Then
      write a function which does this inverse; i.e. given the string
      representation, construct the tree in the usual form.  Finally,
      combine the two predicates in a single
      function <code>tree_string</code> which can be used in both
      directions.</li>
    <li>Write the same predicate <code>tree_string</code> using
      difference lists and a single predicate <code>tree_dlist</code>
      which does the conversion between a tree and a difference list in
      both directions.</li>
  </ul>
  <p>For simplicity, suppose the information in the nodes is a single
    letter and there are no spaces in the string. </p>
  <button class="solution" onclick="toggleContent('q67')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q68" class="question medium">
  <div class="title">Preorder and inorder sequences of binary
    trees</div>
  <p>We consider binary trees with nodes that are identified by single
    lower-case letters, as in the example of the previous problem.</p>
  <ol>
    <li>Write functions <code>preorder</code> and <code>inorder</code>
      that construct the preorder and inorder sequence of a given binary
      tree, respectively.  The results should be atoms, e.g. 'abdecfg' for
      the preorder sequence of the example in the previous problem.
    </li>
    <li>Can you use <code>preorder</code> from problem part 1. in the reverse
      direction; i.e. given a preorder sequence, construct a corresponding
      tree? If not, make the necessary arrangements.</li>
    <li>If both the preorder sequence and the inorder sequence of the
      nodes of a binary tree are given, then the tree is determined
      unambiguously. Write a function <code>pre_in_tree</code> that does
      the job.</li>
    <li>Solve problems 1. to 3. using difference lists.  Cool!  Use the
      function <code>timeit</code> (defined in problem
      “<a href="#timeit">Compare the two methods of calculating Euler's
	totient function.</a>”) to compare the solutions.</li>
  </ol>
  <p>What happens if the same character appears in more than one
    node. Try for instance <code>pre_in_tree "aba" "baa"</code>. </p>
  <button class="solution" onclick="toggleContent('q68')">Solution</button>
  <pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q69" class="question medium">
  <div class="title">Dotstring representation of binary trees</div>
  <p>We consider again binary trees with nodes that are identified by
    single lower-case letters, as in the example of problem
    “<a href="#tree-string">A string representation of binary
      trees</a>”. Such a tree can be represented by the preorder sequence
    of its nodes in which dots (.) are inserted where an empty subtree
    (nil) is encountered during the tree traversal. For example, the
    tree shown in problem “<a href="#tree-string">A string
      representation of binary trees</a>” is represented as
    'abd..e..c.fg...'.  First, try to establish a syntax (BNF or syntax
    diagrams) and then write a function <code>tree_dotstring</code>
    which does the conversion in both directions.  Use difference
    lists. </p>
  <button class="solution" onclick="toggleContent('q69')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>



<h2><a name="mult-tree"></a>Multiway Trees</h2>

<img src="https://sites.google.com/site/prologsite/_/rsrc/1264946214751/prolog-problems/5/p70.gif" style="float:right; padding-left: 1em" alt="multiway tree"/>
<p><em>A multiway tree is composed of a root element and a (possibly
    empty) set of successors which are multiway trees themselves.  A
    multiway tree is never empty. The set of successor trees is sometimes
    called a forest.</em></p>
<p>To represent multiway trees, we will use the following type which
  is a direct translation of the definition:</p>
<pre style="width: 80%"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">type</span> 'a <span class="ocaml-mod">mult_tree</span> = T <span class="kwb">of</span> 'a * 'a mult_tree list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>type 'a mult_tree = T of 'a * 'a mult_tree list
</span></pre>
<p>The example tree depicted opposite is therefore represented by the
  following OCaml expression:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">T('a', [T('f',[T('g',[])]); T('c',[]); T('b',[T('d',[]); T('e',[])])])</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : char mult_tree =
T ('a',
 [T ('f', [T ('g', [])]); T ('c', []);
  T ('b', [T ('d', []); T ('e', ...); ...]); ...])
</span></pre>

<div id="q70_c" class="question easy">
  <div class="title">Count the nodes of a multiway tree</div>
  <button class="solution" onclick="toggleContent('q70_c')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input">let rec count_nodes (T(_, sub)) =
    <span class="ocaml-mod">List</span>.fold_left (<span class="kwb">fun</span> n t -&gt; n + count_nodes t) 1 sub</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val count_nodes : 'a mult_tree -&gt; int = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">count_nodes (T('a', [T('f',[]) ])) = 2</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q70" class="question medium">
  <img src="https://sites.google.com/site/prologsite/_/rsrc/1264946214751/prolog-problems/5/p70.gif" style="float:right" alt="multiway tree"/>
  <div class="title">Tree construction from a node string</div>
  <p>We suppose that the nodes of a multiway tree contain single
    characters.  In the depth-first order sequence of its nodes, a
    special character <code>^</code> has been inserted whenever, during
    the tree traversal, the move is a backtrack to the previous
    level.</p>
  <p>By this rule, the tree in the figure opposite is represented as:
    <code>afg^^c^bd^e^^^</code>.</p>
  <p>Write functions
    <code>string_of_tree : char mult_tree -> string</code> to construct
    the string representing the tree and
    <code>tree_of_string : string -> char mult_tree</code> to construct
    the tree when the string is given.  </p>
  <button class="solution" onclick="toggleContent('q70')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* We could build the final string by string concatenation but this is
     expensive due <span class="kwb">to</span> the number <span class="kwb">of</span> operations.  We use a buffer instead. *)</span>
  let rec add_string_of_tree buf (T(c, sub)) =
    <span class="ocaml-mod">Buffer</span>.add_char buf c;
    <span class="ocaml-mod">List</span>.iter (add_string_of_tree buf) sub;
    <span class="ocaml-mod">Buffer</span>.add_char buf '^'
  <span class="kwa">let</span> <span class="ocaml-function">string_of_tree</span> <span class="ocaml-variable">t </span>=
    <span class="kwa">let </span><span class="ocaml-variable">buf</span> = <span class="ocaml-mod">Buffer</span>.create 128 <span class="kwa">in</span>
    add_string_of_tree buf t;
    <span class="ocaml-mod">Buffer</span>.contents buf</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val add_string_of_tree : Buffer.t -&gt; char mult_tree -&gt; unit = &lt;fun&gt;
val string_of_tree : char mult_tree -&gt; string = &lt;fun&gt;
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">tree_of_substring</span> <span class="ocaml-variable">t s i len </span>=
    <span class="kwb">if</span> i &gt;= len || s.[i] = '^' <span class="kwb">then</span> <span class="ocaml-mod">List</span>.rev t, i + 1
    <span class="kwb">else</span>
      let sub, j = tree_of_substring [] s (i+1) len <span class="kwa">in</span>
      tree_of_substring (T(s.[i], sub) ::t) s j len
  <span class="kwa">let</span> <span class="ocaml-function">tree_of_string</span> <span class="ocaml-variable">s </span>=
    <span class="kwb">match</span> tree_of_substring [] s 0 (<span class="ocaml-mod">String</span>.length s) <span class="kwb">with</span>
    | [t], _ -&gt; t
    | _ -&gt; <span class="kwb">failwith</span> &quot;tree_of_string&quot;</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val tree_of_substring :
  char mult_tree list -&gt; string -&gt; int -&gt; int -&gt; char mult_tree list * int =
  &lt;fun&gt;
val tree_of_string : string -&gt; char mult_tree = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">t</span> =
    T('a', [T('f',[T('g',[])]); T('c',[]); T('b',[T('d',[]); T('e',[])])])</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val t : char mult_tree =
  T ('a',
   [T ('f', [T ('g', [])]); T ('c', []);
    T ('b', [T ('d', []); T ('e', ...); ...]); ...])
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">string_of_tree t = &quot;afg^^c^bd^e^^^&quot;</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">tree_of_string &quot;afg^^c^bd^e^^^&quot; = t</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q71" class="question easy">
  <div class="title">Determine the internal path length of a
    tree</div>
  <p>We define the internal path length of a multiway tree as the total
    sum of the path lengths from the root to all nodes of the tree.  By
    this definition, the tree <code>t</code> in the figure of the
    previous problem has an internal path length of 9.  Write a
    function <code>ipl tree</code> that returns the internal path length
    of <code>tree</code>.</p>
  <button class="solution" onclick="toggleContent('q71')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input">let rec ipl_sub len (T(_, sub)) =
    <span class="ocaml-comment">(* [len] is the distance <span class="kwb">of</span> the current node <span class="kwb">to</span> the root.  Add the
       distance <span class="kwb">of</span> all sub-nodes. *)</span>
    <span class="ocaml-mod">List</span>.fold_left (<span class="kwb">fun</span> sum t -&gt; sum + ipl_sub (len + 1) t) len sub
  <span class="kwa">let</span> <span class="ocaml-function">ipl</span> <span class="ocaml-variable">t </span>= ipl_sub 0 t</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val ipl_sub : int -&gt; 'a mult_tree -&gt; int = &lt;fun&gt;
val ipl : 'a mult_tree -&gt; int = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">ipl t = 9</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q72" class="question easy">
  <div class="title">Construct the bottom-up order sequence of the
    tree nodes</div>
  <p>Write a function <code>bottom_up t</code> which constructs the
    bottom-up sequence of the nodes of the multiway
    tree <code>t</code>.</p>
  <button class="solution" onclick="toggleContent('q72')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input">let rec prepend_bottom_up (T(c, sub)) l =
    <span class="ocaml-mod">List</span>.fold_right (<span class="kwb">fun</span> t l -&gt; prepend_bottom_up t l) sub (c :: l)
  <span class="kwa">let</span> <span class="ocaml-function">bottom_up</span> <span class="ocaml-variable">t </span>= prepend_bottom_up t []</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val prepend_bottom_up : 'a mult_tree -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
val bottom_up : 'a mult_tree -&gt; 'a list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">bottom_up (T('a', [T('b', [])])) = ['b'; 'a']</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">bottom_up t = ['g'; 'f'; 'c'; 'd'; 'e'; 'b'; 'a']</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q73" class="question medium">
  <div class="title">Lisp-like tree representation</div>
  <p>There is a particular notation for multiway trees in Lisp.  The
    following pictures show how multiway tree structures are represented
    in Lisp.</p>
  <center>
    <img src="https://sites.google.com/site/prologsite/_/rsrc/1264946557086/prolog-problems/5/p73.png" alt="Lisp representation of multiway trees"/>
  </center>
  <p>Note that in the "lispy" notation a node with successors (children)
    in the tree is always the first element in a list, followed by its
    children.  The "lispy" representation of a multiway tree is a sequence
    of atoms and parentheses '(' and ')'.  This is very close to the way
    trees are represented in OCaml, except that no
    constructor <code>T</code> is used.  Write a function <code>lispy :
      char mult_tree -> string</code> that returns the lispy notation of
    the tree.</p>
  <button class="solution" onclick="toggleContent('q73')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">add_lispy</span> <span class="ocaml-variable">buf </span>= <span class="kwb">function</span>
    | T(c, []) -&gt; <span class="ocaml-mod">Buffer</span>.add_char buf c
    | T(c, sub) -&gt;
       <span class="ocaml-mod">Buffer</span>.add_char buf '(';
       <span class="ocaml-mod">Buffer</span>.add_char buf c;
       <span class="ocaml-mod">List</span>.iter (<span class="kwb">fun</span> t -&gt; <span class="ocaml-mod">Buffer</span>.add_char buf ' '; add_lispy buf t) sub;
       <span class="ocaml-mod">Buffer</span>.add_char buf ')'
  <span class="kwa">let</span> <span class="ocaml-function">lispy</span> <span class="ocaml-variable">t </span>=
    <span class="kwa">let </span><span class="ocaml-variable">buf</span> = <span class="ocaml-mod">Buffer</span>.create 128 <span class="kwa">in</span>
    add_lispy buf t;
    <span class="ocaml-mod">Buffer</span>.contents buf</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val add_lispy : Buffer.t -&gt; char mult_tree -&gt; unit = &lt;fun&gt;
val lispy : char mult_tree -&gt; string = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">lispy (T('a', [])) = &quot;a&quot;</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">lispy (T('a', [T('b', [])])) = &quot;(a b)&quot;</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">lispy t = &quot;(a (f g) c (b d e))&quot;</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>


<h2><a name="graphs"></a>Graphs</h2>

<p><em>A graph is defined as a set of nodes and a set of edges, where
    each edge is a pair of different nodes.</em></p>

<img src="https://sites.google.com/site/prologsite/_/rsrc/1264948248705/prolog-problems/6/graph1.gif" style="float:right; padding-left: 1em" alt="A graph"/>
<p>There are several ways to represent graphs in OCaml.</p>
<ul>
  <li style="padding-bottom: 2ex">One method is to list all edges, an edge being a pair of nodes.
    In this form, the graph depicted opposite is represented as the
    following expression:
    <pre style="width: 75%"><span class="ocamltop-prompt"># </span><span class="ocamltop-input">['h', 'g';  'k', 'f';  'f', 'b';  'f', 'c';  'c', 'b']</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : (char * char) list =
[('h', 'g'); ('k', 'f'); ('f', 'b'); ('f', 'c'); ('c', 'b')]
</span></pre>
    We call this <strong>edge-clause form</strong>.
    Obviously, isolated nodes cannot be represented.
  </li>

  <li style="padding-bottom: 2ex">Another method is to represent the whole graph as one data
    object.  According to the definition of the graph as a pair of two
    sets (nodes and edges), we may use the following OCaml type:
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">type</span> 'a <span class="ocaml-mod">graph_term</span> = { nodes : 'a list;  edges : ('a * 'a) list }</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>type 'a graph_term = { nodes : 'a list; edges : ('a * 'a) list; }
</span></pre>
    Then, the above example graph is represented by:
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">example_graph</span> =
    { nodes = ['b'; 'c'; 'd'; 'f'; 'g'; 'h'; 'k'];
      edges = ['h', 'g';  'k', 'f';  'f', 'b';  'f', 'c';  'c', 'b'] }</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val example_graph : char graph_term =
  {nodes = ['b'; 'c'; 'd'; 'f'; 'g'; 'h'; 'k'];
   edges = [('h', 'g'); ('k', 'f'); ('f', 'b'); (...); ...]}
</span></pre>
    <p>We call this <strong>graph-term form</strong>. Note, that the
    lists are kept sorted, they are really sets, without duplicated
    elements. Each edge appears only once in the edge list; i.e. an
    edge from a node x to another node y is represented
    as <code>(x,y)</code>, the couple <code>(y,x)</code> is not
    present. The <strong>graph-term form is our default
    representation.</strong> You may want to define a similar type
    using sets instead of lists.
    </p>
  </li>

  <li style="padding-bottom: 2ex">
    A third representation method is to associate with each node the set
    of nodes that are adjacent to that node. We call this the
    <strong>adjacency-list form</strong>.  In our example:
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
  </li>

  <li>The representations we introduced so far well suited for
    automated processing, but their syntax is not very user-friendly.
    Typing the terms by hand is cumbersome and error-prone.  We can
    define a more compact and "human-friendly" notation as follows: A
    graph (with char labelled nodes) is represented by a string of
    atoms and terms of the type X-Y.  The atoms stand for isolated
    nodes, the X-Y terms describe edges.  If an X appears as an
    endpoint of an edge, it is automatically defined as a node. Our
    example could be written as:
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">&quot;b-c f-c g-h d f-b k-f h-g&quot;</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : string = &quot;b-c f-c g-h d f-b k-f h-g&quot;
</span></pre>
    <p>We call this the <strong>human-friendly form</strong>.  As the
      example shows, the list does not have to be sorted and may even
      contain the same edge multiple times. Notice the isolated node
      <code>d</code>. </p>
  </li>
</ul>

<div id="q80" class="question easy">
  <div class="title">Conversions</div>
  <p>Write functions to convert between the different graph
    representations. With these functions, all representations are
    equivalent; i.e. for the following problems you can always pick freely
    the most convenient form.   This problem is
    not particularly difficult,  but it's a lot of
    work to deal with all the special cases. </p>
  <button class="solution" onclick="toggleContent('q80')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q81" class="question medium">
  <div class="title">Path from one node to another one</div>
  <p>Write a function <code>paths g a b</code> that returns all acyclic
    path <code>p</code> from node <code>a</code> to node <code>b ≠ a</code>
    in the graph <code>g</code>. The function should return the list of
    all paths via backtracking. </p>
  <button class="solution" onclick="toggleContent('q81')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* The datastructures used here are far from the most efficient ones
     but allow <span class="kwb">for</span> a straightforward implementation. *)</span>
  <span class="ocaml-comment">(* Returns all neighbors satisfying the condition. *)</span>
  <span class="kwa">let</span> <span class="ocaml-function">neighbors</span> <span class="ocaml-variable">g a cond </span>=
    let edge l (b,c) = <span class="kwb">if</span> b = a &amp;&amp; cond c <span class="kwb">then</span> c :: l
                       <span class="kwb">else</span> <span class="kwb">if</span> c = a &amp;&amp; cond b <span class="kwb">then</span> b :: l
                       <span class="kwb">else</span> l <span class="kwa">in</span>
    <span class="ocaml-mod">List</span>.fold_left edge [] g.edges
  <span class="kwa">let rec</span> <span class="ocaml-function">list_path</span> <span class="ocaml-variable">g a to_b </span>= <span class="kwb">match</span> to_b <span class="kwb">with</span>
    | [] -&gt; <span class="kwb">assert</span> false <span class="ocaml-comment">(* [to_b] contains the path <span class="kwb">to</span> [b]. *)</span>
    | a' :: _ -&gt;
       <span class="kwb">if</span> a' = a <span class="kwb">then</span> [to_b]
       <span class="kwb">else</span>
         <span class="kwa">let </span><span class="ocaml-variable">n</span> = neighbors g a' (<span class="kwb">fun</span> c -&gt; not(<span class="ocaml-mod">List</span>.mem c to_b)) <span class="kwa">in</span>
         <span class="ocaml-mod">List</span>.concat(<span class="ocaml-mod">List</span>.map (<span class="kwb">fun</span> c -&gt; list_path g a (c :: to_b)) n)

  <span class="kwa">let</span> <span class="ocaml-function">paths</span> <span class="ocaml-variable">g a b </span>=
    <span class="kwb">assert</span>(a &lt;&gt; b);
    list_path g a [b]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val neighbors : 'a graph_term -&gt; 'a -&gt; ('a -&gt; bool) -&gt; 'a list = &lt;fun&gt;
val list_path : 'a graph_term -&gt; 'a -&gt; 'a list -&gt; 'a list list = &lt;fun&gt;
val paths : 'a graph_term -&gt; 'a -&gt; 'a -&gt; 'a list list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">paths example_graph 'f' 'b' = [['f'; 'c'; 'b']; ['f'; 'b']]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q82" class="question easy">
  <div class="title">Cycle from a given node</div>
  <p>Write a functions <code>cycle g a</code> that returns a closed path
    (cycle) <code>p</code> starting at a given node <code>a</code> in
    the graph <code>g</code>. The predicate should return the list of
    all cycles via backtracking. </p>
  <button class="solution" onclick="toggleContent('q82')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">cycles</span> <span class="ocaml-variable">g a </span>=
    <span class="kwa">let </span><span class="ocaml-variable">n</span> = neighbors g a (<span class="kwb">fun</span> _ -&gt; true) <span class="kwa">in</span>
    <span class="kwa">let </span><span class="ocaml-variable">p</span> = <span class="ocaml-mod">List</span>.concat(<span class="ocaml-mod">List</span>.map (<span class="kwb">fun</span> c -&gt; list_path g a [c]) n) <span class="kwa">in</span>
    <span class="ocaml-mod">List</span>.map (<span class="kwb">fun</span> p -&gt; p @ [a]) p</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val cycles : 'a graph_term -&gt; 'a -&gt; 'a list list = &lt;fun&gt;
</span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">cycles example_graph 'f'
  = [['f'; 'b'; 'c'; 'f']; ['f'; 'c'; 'f']; ['f'; 'c'; 'b'; 'f'];
     ['f'; 'b'; 'f']; ['f'; 'k'; 'f']]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = true
</span></pre>
</div>

<div id="q83" class="question medium">
  <div class="title">Construct all spanning trees</div>
  <img src="https://sites.google.com/site/prologsite/_/rsrc/1264949059996/prolog-problems/6/p83.gif" style="float: right; padding-left: 1em" alt="Spanning tree graph"/>
  <p>Write a function <code>s_tree g</code> to construct (by
    backtracking) all
    <a target="_blank" href="http://en.wikipedia.org/wiki/Spanning_tree">spanning
      trees</a> of a given graph <code>g</code>.  With this predicate,
    find out how many spanning trees there are for the graph depicted to
    the left.  The data of this example graph can be found in the test
    below.  When you have a correct solution for the
    <code>s_tree</code> function, use it to define two other useful
    functions: <code>is_tree graph</code> and <code>is_connected
      Graph</code>.  Both are five-minutes tasks! </p>
  <button class="solution" onclick="toggleContent('q83')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">g</span> = { nodes = ['a'; 'b'; 'c'; 'd'; 'e'; 'f'; 'g'; 'h'];
            edges = [('a', 'b'); ('a', 'd'); ('b', 'c'); ('b', 'e');
                     ('c', 'e'); ('d', 'e'); ('d', 'f'); ('d', 'g');
                     ('e', 'h'); ('f', 'g'); ('g', 'h')] }</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val g : char graph_term =
  {nodes = ['a'; 'b'; 'c'; 'd'; 'e'; 'f'; 'g'; 'h'];
   edges = [('a', 'b'); ('a', 'd'); ('b', 'c'); ...]}
</span></pre>
</div>


<div id="q84" class="question medium">
  <img src="https://sites.google.com/site/prologsite/_/rsrc/1264949163407/prolog-problems/6/p84.gif" style="float: right; padding-left: 1em" alt="Spanning tree graph"/>
  <div class="title">Construct the minimal spanning tree</div>
  <p> Write a function <code>ms_tree graph</code> to construct
    the minimal spanning tree of a given labelled graph.  A labelled
    graph will be represented as follows:</p>
<pre style="width: 80%"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">type</span> ('a, 'b) labeled_graph = { nodes : 'a list;
                                  edges : ('a * 'a * 'b) list }</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>type ('a, 'b) labeled_graph = {
  nodes : 'a list;
  edges : ('a * 'a * 'b) list;
}
</span></pre>
  <p>(Beware that from now on <code>nodes</code> and <code>edges</code>
    mask the previous fields of the same name.)</p>
  <p>Hint: Use the
    <a href="http://en.wikipedia.org/wiki/Prim%27s_algorithm">algorithm
      of Prim</a>.  A small modification of the solution of P83 does the
    trick. The data of the example graph to the right can be found
    below.</p>
  <button class="solution" onclick="toggleContent('q84')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">g</span> = { nodes = ['a'; 'b'; 'c'; 'd'; 'e'; 'f'; 'g'; 'h'];
            edges = [('a', 'b', 5); ('a', 'd', 3); ('b', 'c', 2); ('b', 'e', 4);
                     ('c', 'e', 6); ('d', 'e', 7); ('d', 'f', 4); ('d', 'g', 3);
                     ('e', 'h', 5); ('f', 'g', 4); ('g', 'h', 1)] }</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val g : (char, int) labeled_graph =
  {nodes = ['a'; 'b'; 'c'; 'd'; 'e'; 'f'; 'g'; 'h'];
   edges = [('a', 'b', 5); ('a', 'd', 3); (...); ...]}
</span></pre>
</div>

<div id="q85" class="question medium">
  <div class="title">Graph isomorphism</div>
  <p>Two graphs G1(N1,E1) and G2(N2,E2) are isomorphic if there is a
    bijection f: N1 → N2 such that for any nodes X,Y of N1, X and Y are
    adjacent if and only if f(X) and f(Y) are adjacent.</p>
  <p>Write a function that determines whether two graphs are isomorphic.
    Hint: Use an open-ended list to represent the function f. </p>
  <button class="solution" onclick="toggleContent('q85')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q86" class="question medium">
  <div class="title">Node degree and graph coloration</div>
  <ul>
    <li>Write a function <code>degree graph node</code> that determines the
      degree of a given node.</li>
    <li>Write a function that generates a list of all nodes of a graph
      sorted according to decreasing degree.</li>
    <li>Use <a href="http://en.wikipedia.org/wiki/Graph_coloring#Greedy_coloring">Welsh-Powell's algorithm</a> to paint the nodes of a graph in
      such a way that adjacent nodes have different colors.</li>
  </ul>
  <button class="solution" onclick="toggleContent('q86')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q87" class="question medium">
  <div class="title">Depth-first order graph traversal</div>
  <p>Write a function that generates a depth-first order graph
    traversal sequence.  The starting point should be specified, and the
    output should be a list of nodes that are reachable from this starting
    point (in depth-first order). </p>
  <button class="solution" onclick="toggleContent('q87')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q88" class="question medium">
  <div class="title">Connected components</div>
  <p>Write a predicate that splits a graph into its
    <a href="http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29">connected components</a>.</p>
  <button class="solution" onclick="toggleContent('q88')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q89" class="question medium">
  <div class="title">Bipartite graphs</div>
  <p> Write a predicate that finds out whether a given graph is
    <a href="http://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a>.</p>
  <button class="solution" onclick="toggleContent('q89')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q89+1" class="question hard">
  <div class="title">Generate K-regular simple graphs with N
    nodes</div>
  <p>In
    a <a href="http://en.wikipedia.org/wiki/K-regular_graph">K-regular
      graph</a> all nodes have a degree of K; i.e. the number of edges
    incident in each node is K. How many (non-isomorphic!)  3-regular
    graphs with 6 nodes are there?</p>
  <p>See also
    the <a href="https://sites.google.com/site/prologsite/prolog-problems/6/solutions-6/p6_11.txt?attredirects=0&d=1">table of results</a>.</p>
  <button class="solution" onclick="toggleContent('q89+1')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>



<h2><a name="misc"></a>Miscellaneous Problems</h2>


<div id="q90" class="question medium">
  <div class="title">Eight queens problem</div>
  <p>This is a classical problem in computer science. The objective is
    to place eight queens on a chessboard so that no two queens are
    attacking each other; i.e., no two queens are in the same row, the
    same column, or on the same diagonal.</p>
  <p>
    Hint: Represent the positions of the queens as a list of numbers
    1..N. Example: <code>[4;2;7;3;6;8;5;1]</code> means that the queen
    in the first column is in row 4, the queen in the second column is
    in row 2, etc. Use the generate-and-test paradigm.</p>
  <button class="solution" onclick="toggleContent('q90')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q91" class="question medium">
  <div class="title">Knight's tour</div>
  <p>Another famous problem is this one: How can a knight jump on an N×N
    chessboard in such a way that it visits every square exactly
    once?</p>
  <p>
    Hints: Represent the squares by pairs of their coordinates
    <code>(x,y)</code>, where both <code>x</code> and <code>y</code> are
    integers between 1 and N.  Define the function <code>jump n
      (x,y)</code> that returns all coordinates <code>(u,v)</code> to
    which a knight can jump from <code>(x,y)</code> to on
    a <code>n</code>×<code>n</code> chessboard.  And finally, represent
    the solution of our problem as a list knight positions (the
    knight's tour). </p>
  <button class="solution" onclick="toggleContent('q91')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q92" class="question hard">
  <div class="title">Von Koch's conjecture</div>
  <p>Several years ago I met a mathematician who was intrigued by a
    problem for which he didn't know a solution. His name was Von Koch,
    and I don't know whether the problem has been solved since.</p>
  <img src="https://sites.google.com/site/prologsite/_/rsrc/1264955485190/prolog-problems/7/p92a.gif" style="float: right; padding-left: 1em" alt="Tree numbering"/>
  <p>Anyway, the puzzle goes like this: Given a tree with N nodes (and
    hence N-1 edges). Find a way to enumerate the nodes from 1 to N and,
    accordingly, the edges from 1 to N-1 in such a way, that for each edge
    K the difference of its node numbers equals to K. The conjecture is
    that this is always possible.</p>
  <p>For small trees the problem is easy to solve by hand. However, for
    larger trees, and 14 is already very large, it is extremely difficult
    to find a solution.  And remember, we don't know for sure whether there
    is always a solution!</p>
  <center>
    <img src="https://sites.google.com/site/prologsite/_/rsrc/1264955528417/prolog-problems/7/p92b.gif" alt="Larger tree"/>
  </center>
  <p>Write a function that calculates a numbering scheme for a given
    tree.  What is the solution for the larger tree pictured above?</p>
  <button class="solution" onclick="toggleContent('q92')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q93" class="question hard">
  <div class="title">An arithmetic puzzle</div>
  <p>
    Given a list of integer numbers, find a correct way of inserting
    arithmetic signs (operators) such that the result is a correct
    equation.  Example: With the list of
    numbers <code>[2;3;5;7;11]</code> we can form the equations 2-3+5+7
    = 11 or 2 = (3*5+7)/11 (and ten others!).</p>
  <button class="solution" onclick="toggleContent('q93')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q94" class="question medium">
  <div class="title">English number words</div>
  <p>On financial documents, like cheques, numbers must sometimes be
    written in full words.  Example: 175 must be written as
    one-seven-five.  Write a function <code>full_words</code> to print
    (non-negative) integer numbers in full words. </p>
  <button class="solution" onclick="toggleContent('q94')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q95" class="question medium">
  <div class="title">Syntax checker</div>
  <img src="https://sites.google.com/site/prologsite/_/rsrc/1264955783053/prolog-problems/7/p96.gif" alt="Syntax graph"/>
  <p>In a certain programming language (Ada) identifiers are defined by
    the syntax diagram (railroad chart) opposite. Transform the syntax
    diagram into a system of syntax diagrams which do not contain loops;
    i.e. which are purely recursive. Using these modified diagrams,
    write a function <code>identifier : string -> bool</code> that can
    check whether or not a given string is a legal identifier.</p>
  <button class="solution" onclick="toggleContent('q95')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q96" class="question medium">
  <div class="title">Sudoku</div>
  <p>Sudoku puzzles go like this: </p>
<pre>
   Problem statement                 Solution

    .  .  4 | 8  .  . | .  1  7	     9  3  4 | 8  2  5 | 6  1  7
            |         |                      |         |
    6  7  . | 9  .  . | .  .  .	     6  7  2 | 9  1  4 | 8  5  3
            |         |                      |         |
    5  .  8 | .  3  . | .  .  4      5  1  8 | 6  3  7 | 9  2  4
    --------+---------+--------      --------+---------+--------
    3  .  . | 7  4  . | 1  .  .      3  2  5 | 7  4  8 | 1  6  9
            |         |                      |         |
    .  6  9 | .  .  . | 7  8  .      4  6  9 | 1  5  3 | 7  8  2
            |         |                      |         |
    .  .  1 | .  6  9 | .  .  5      7  8  1 | 2  6  9 | 4  3  5
    --------+---------+--------      --------+---------+--------
    1  .  . | .  8  . | 3  .  6	     1  9  7 | 5  8  2 | 3  4  6
            |         |                      |         |
    .  .  . | .  .  6 | .  9  1	     8  5  3 | 4  7  6 | 2  9  1
            |         |                      |         |
    2  4  . | .  .  1 | 5  .  .      2  4  6 | 3  9  1 | 5  7  8
</pre>
  <p>Every spot in the puzzle belongs to a (horizontal) row and a
    (vertical) column, as well as to one single 3x3 square (which we call
    "square" for short). At the beginning, some of the spots carry a
    single-digit number between 1 and 9. The problem is to fill the
    missing spots with digits in such a way that every number between 1
    and 9 appears exactly once in each row, in each column, and in each
    square.</p>
  <button class="solution" onclick="toggleContent('q96')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q97" class="question hard">
  <div class="title">Nonograms</div>
  <p>Around 1994, a certain kind of puzzles was very popular in
    England. The "Sunday Telegraph" newspaper wrote: "Nonograms are
    puzzles from Japan and are currently published each week only in The
    Sunday Telegraph. Simply use your logic and skill to complete the grid
    and reveal a picture or diagram." As an OCaml programmer, you are in a
    better situation: you can have your computer do the work!
  </p>
  <p>The puzzle goes like this: Essentially, each row and column of a
    rectangular bitmap is annotated with the respective lengths of its
    distinct strings of occupied cells. The person who solves the puzzle
    must complete the bitmap given only these lengths. </p>
<pre>
          Problem statement:          Solution:

          |_|_|_|_|_|_|_|_| 3         |_|X|X|X|_|_|_|_| 3
          |_|_|_|_|_|_|_|_| 2 1       |X|X|_|X|_|_|_|_| 2 1
          |_|_|_|_|_|_|_|_| 3 2       |_|X|X|X|_|_|X|X| 3 2
          |_|_|_|_|_|_|_|_| 2 2       |_|_|X|X|_|_|X|X| 2 2
          |_|_|_|_|_|_|_|_| 6         |_|_|X|X|X|X|X|X| 6
          |_|_|_|_|_|_|_|_| 1 5       |X|_|X|X|X|X|X|_| 1 5
          |_|_|_|_|_|_|_|_| 6         |X|X|X|X|X|X|_|_| 6
          |_|_|_|_|_|_|_|_| 1         |_|_|_|_|X|_|_|_| 1
          |_|_|_|_|_|_|_|_| 2         |_|_|_|X|X|_|_|_| 2
           1 3 1 7 5 3 4 3             1 3 1 7 5 3 4 3
           2 1 5 1                     2 1 5 1
</pre>
  <p>For the example above, the problem can be stated as the two lists
    <code>[[3];[2;1];[3;2];[2;2];[6];[1;5];[6];[1];[2]]</code> and
    <code>[[1;2];[3;1];[1;5];[7;1];[5];[3];[4];[3]]</code> which give
    the "solid" lengths of the rows and columns, top-to-bottom and
    left-to-right, respectively. Published puzzles are larger than this
    example, e.g. 25×20, and apparently always have unique
    solutions. </p>
  <button class="solution" onclick="toggleContent('q97')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>

<div id="q98" class="question hard">
  <div class="title">Crossword puzzle</div>
  <p>Given an empty (or almost empty) framework of a crossword puzzle
    and a set of words. The problem is to place the words into the
    framework.</p>
  <center>
    <img src="https://sites.google.com/site/prologsite/prolog-problems/7/p99.gif?attredirects=0" alt="puzzle"/>
  </center>
  <p>The particular crossword puzzle is specified in a text file which
    first lists the words (one word per line) in an arbitrary
    order. Then, after an empty line, the crossword framework is
    defined. In this framework specification, an empty character
    location is represented by a dot (.). In order to make the solution
    easier, character locations can also contain predefined character
    values. The puzzle above is defined in the
    file <a href="https://sites.google.com/site/prologsite/prolog-problems/7/solutions-7/p7_09a.dat?attredirects=0&d=1">p7_09a.dat</a>, other examples
    are <a href="https://sites.google.com/site/prologsite/prolog-problems/7/solutions-7/p7_09b.dat?attredirects=0&d=1">p7_09b.dat</a>
    and <a href="https://sites.google.com/site/prologsite/prolog-problems/7/solutions-7/p7_09d.dat?attredirects=0&d=1">p7_09d.dat</a>.  There is also an example of a puzzle
    (<a href="https://sites.google.com/site/prologsite/prolog-problems/7/solutions-7/p7_09c.dat?attredirects=0&d=1">p7_09c.dat</a>) which does not have a solution.</p>
  <p>Words are strings (character lists) of at least two characters. A
    horizontal or vertical sequence of character places in the crossword
    puzzle framework is called a site. Our problem is to find a compatible
    way of placing words onto sites. </p>
  <p><strong>Hints:</strong></p>
  <ol>
    <li>The problem is not easy. You will need some time to thoroughly
      understand it.  So, don't give up too early!  And remember that
      the objective is a clean solution, not just a quick-and-dirty
      hack!</li>
    <li>For efficiency reasons it is important, at least for larger
      puzzles, to sort the words and the sites in a particular
      order. </li>
  </ol>
  <button class="solution" onclick="toggleContent('q98')">Solution</button>
<pre class="solution"><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span></pre>
</div>


  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body></html>
